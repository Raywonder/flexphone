/**
 * ðŸ“± FlexPhone Frontend Application
 * Lightweight SIP phone interface
 */

class FlexPhoneApp {
    constructor() {
        this.currentNumber = '';
        this.isConnected = false;
        this.currentCall = null;
        this.activeTab = 'dialer';
        this.contacts = [];
        this.autoCompleteItems = [];
        this.selectedAutoCompleteIndex = -1;

        // SIP client monitoring
        this.sipClients = [];
        this.autoAnswerEnabled = false;
        this.autoAnswerDelay = 3;
        this.handsFreeMode = false;
        this.intercomEnabled = false;
        this.flexPhoneIntegration = false;

        // Enhanced PBX call state tracking system
        this.pbxCallStates = {
            userStatus: 'available', // available, busy, away, dnd, offline
            activeCall: null,
            heldCalls: [],
            incomingCalls: [],
            outgoingCalls: [],
            queuedCalls: [],
            conferenceMembers: [],
            transferStatus: null,
            recordingActive: false,
            lastStatusUpdate: Date.now()
        };

        // PBX API endpoints for status reporting
        this.pbxAPIEndpoints = {
            statusUpdate: '/api/v1/status/update',
            callState: '/api/v1/calls/state',
            presence: '/api/v1/presence',
            queue: '/api/v1/queue/status',
            extensions: '/api/v1/extensions/status'
        };

        // Initialize PBX status reporting
        this.initializePBXStatusReporting();

        // Queue management state
        this.queueStatus = 'logged-out'; // logged-out, logged-in, paused
        this.availableQueues = [];
        this.joinedQueues = [];

        // Third-party queue system support (disabled by default)
        this.queueSystemSettings = {
            defaultSystem: 'flexpbx',
            thirdPartyEnabled: false, // Disabled by default
            accessibilityApiUrl: 'http://localhost:8080/api/v1/accessibility',
            availableSystems: [
                { id: 'flexpbx', name: 'FlexPBX Default', enabled: true },
                { id: 'asterisk', name: 'Asterisk Queue System', enabled: false },
                { id: 'freeswitch', name: 'FreeSWITCH Event Socket', enabled: false },
                { id: '3cx', name: '3CX Queue System', enabled: false }
            ]
        };
        this.apiKey = null; // For accessibility API authentication

        // Initialize DTMF service
        this.initializeDTMF();

        // Initialize P2P Audio Manager
        this.p2pManager = new P2PAudioManager(this);

        // Initialize VoicePack Audio System
        this.voicePack = new VoicePackManager(this);

        this.initializeElements();
        this.setupEventListeners();
        this.setupIPCListeners();
        this.loadSettings();
        this.loadContacts();

        // Initialize audio devices with enhanced configuration
        this.initializeAudioDevices().catch(error => {
            console.error('Failed to initialize audio devices:', error);
        });

        // Apply startup audio configuration
        // this.applyStartupAudioConfig(); // Temporarily disabled to test frontend initialization

        // Play welcome message after short delay
        setTimeout(() => {
            this.playWelcomeMessage();
        }, 1000);

        console.log('ðŸ“± FlexPhone App initialized');
    }

    initializeDTMF() {
        // DTMF frequency mappings
        this.dtmfFrequencies = {
            '1': [697, 1209], '2': [697, 1336], '3': [697, 1477],
            '4': [770, 1209], '5': [770, 1336], '6': [770, 1477],
            '7': [852, 1209], '8': [852, 1336], '9': [852, 1477],
            '*': [941, 1209], '0': [941, 1336], '#': [941, 1477]
        };

        this.dtmfEnabled = true;
        this.dtmfVolume = 0.1;
        this.dtmfDuration = 200;

        // Initialize AudioContext with built-in device sample rate
        try {
            const audioContextOptions = {
                sampleRate: 44100, // Match built-in device default
                latencyHint: 'interactive' // Low latency for real-time audio
            };
            this.audioContext = new (window.AudioContext || window.webkitAudioContext)(audioContextOptions);
            console.log('ðŸŽµ DTMF AudioContext initialized with sample rate:', this.audioContext.sampleRate);
        } catch (error) {
            console.error('âŒ Failed to initialize DTMF AudioContext:', error);
            this.dtmfEnabled = false;
        }

        // Phone state tracking
        this.phoneOffHook = false;
        this.dialToneOscillator = null;
        this.callOnHold = false;
        this.callOnHoldWithMusic = false;

        // Audio settings with startup configuration (normal volume, unmuted)
        this.outputVolume = 0.7; // 70% - Normal startup volume for output
        this.inputVolume = 0.5; // 50% - Default input volume
        this.outputMuted = false; // Unmuted on startup
        this.inputMuted = false; // Unmuted on startup
        this.autoUnmuteOnStartup = true; // Always unmute on startup

        this.escapeCount = 0; // Track consecutive Escape presses
        this.escapeTimer = null; // Timer for escape sequence

        // Advanced call features
        this.isInConference = false;
        this.ringtoneEnabled = true;
        this.doNotDisturbMode = false;

        // Transfer system
        this.inAttendedTransfer = false;
        this.attendedTransferTarget = null;

        // Call monitoring (disabled by default for privacy)
        this.callMonitoringEnabled = false;

        // Hold music system
        this.holdMusicFiles = [];
        this.currentHoldMusicIndex = 0;
        this.holdMusicAudio = null;
        this.initializeHoldMusicSystem();

        // Speech settings
        this.speechEnabled = true; // Can be toggled in settings
        this.speechSynthesis = window.speechSynthesis;
        this.speechRate = 1.2;
        this.speechPitch = 1.0;
        this.speechVolume = 0.8;
        this.currentVoice = null;
        this.preferScreenReader = false;
        this.voices = [];

        // Initialize speech synthesis
        if (this.speechSynthesis) {
            this.loadVoices();
            this.speechSynthesis.addEventListener('voiceschanged', () => {
                this.loadVoices();
            });
        }
    }

    initializeElements() {
        // Dialer elements
        this.dialerDisplay = document.getElementById('dialerDisplay');
        this.dialerInput = document.getElementById('dialerInput');
        this.autoCompleteDropdown = document.getElementById('autoCompleteDropdown');
        this.dtmfStatus = document.getElementById('dtmfStatus');
        this.dtmfIndicator = document.getElementById('dtmfIndicator');
        this.dtmfEnabledText = document.getElementById('dtmfEnabled');
        this.callBtn = document.getElementById('callBtn');
        this.hangupBtn = document.getElementById('hangupBtn');
        this.clearBtn = document.getElementById('clearBtn');
        this.smsBtn = document.getElementById('smsBtn');
        this.testDTMFBtn = document.getElementById('testDTMFBtn');
        this.addContactBtn = document.getElementById('addContactBtn');

        // Settings elements
        this.sipProvider = document.getElementById('sipProvider');
        this.sipServer = document.getElementById('sipServer');
        this.sipPort = document.getElementById('sipPort');
        this.sipUsername = document.getElementById('sipUsername');
        this.sipPassword = document.getElementById('sipPassword');
        this.sipDisplayName = document.getElementById('sipDisplayName');
        this.connectBtn = document.getElementById('connectBtn');
        this.disconnectBtn = document.getElementById('disconnectBtn');
        this.saveSettingsBtn = document.getElementById('saveSettingsBtn');

        // Advanced SIP features
        this.autoAnswerEnabled = document.getElementById('autoAnswerEnabled');
        this.autoAnswerDelay = document.getElementById('autoAnswerDelay');
        this.handsFreeMode = document.getElementById('handsFreeMode');
        this.intercomEnabled = document.getElementById('intercomEnabled');
        this.flexPhoneIntegration = document.getElementById('flexPhoneIntegration');

        // SIP clients elements
        this.onlineCount = document.getElementById('onlineCount');
        this.busyCount = document.getElementById('busyCount');
        this.offlineCount = document.getElementById('offlineCount');
        this.sipClientsList = document.getElementById('sipClientsList');
        this.intercomMessage = document.getElementById('intercomMessage');
        this.sendIntercomBtn = document.getElementById('sendIntercomBtn');

        // Status elements
        this.statusIndicator = document.getElementById('statusIndicator');
        this.connectionStatus = document.getElementById('connectionStatus');

        // Incoming call elements
        this.incomingCallOverlay = document.getElementById('incomingCallOverlay');
        this.callerName = document.getElementById('callerName');
        this.callerNumber = document.getElementById('callerNumber');
        this.answerBtn = document.getElementById('answerBtn');
        this.declineBtn = document.getElementById('declineBtn');

        // Tab elements
        this.navTabs = document.querySelectorAll('.nav-tab');
        this.tabContents = document.querySelectorAll('.tab-content');
    }

    setupEventListeners() {
        // Keypad
        document.querySelectorAll('.key').forEach(key => {
            key.addEventListener('click', () => {
                const digit = key.dataset.digit;
                // Ensure audio context is ready for DTMF tones
                this.ensureAudioContextReady().then(() => {
                    this.addDigit(digit);
                });
            });
        });

        // Call controls
        this.callBtn.addEventListener('click', () => {
            this.ensureAudioContextReady().then(() => this.makeCall());
        });
        this.hangupBtn.addEventListener('click', () => {
            this.ensureAudioContextReady().then(() => this.hangupCall());
        });
        this.clearBtn.addEventListener('click', () => this.clearDisplay());

        // Connection controls
        this.connectBtn.addEventListener('click', () => this.connectSIP());
        this.disconnectBtn.addEventListener('click', () => this.disconnectSIP());

        // Incoming call controls
        this.answerBtn.addEventListener('click', () => this.answerCall());
        this.declineBtn.addEventListener('click', () => this.declineCall());

        // Tab navigation
        this.navTabs.forEach(tab => {
            tab.addEventListener('click', () => {
                const tabName = tab.dataset.tab;
                this.switchTab(tabName);
            });
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            // Ctrl+Shift speech control layer
            if (this.handleSpeechControls(e)) {
                return; // Speech control was handled
            }

            // Global F-key shortcuts (work in any tab)
            if (this.handleFunctionKeys(e)) {
                return; // F-key was handled
            }

            // Test tone keys: ~ (backtick) and Shift+~ (tilde)
            if (this.handleTestToneKeys(e)) {
                return; // Test tone key was handled
            }

            // Cmd+, for settings (macOS standard)
            if ((e.metaKey || e.ctrlKey) && e.key === ',') {
                e.preventDefault();
                this.openSettingsWindow();
                return;
            }

            // Dialer-specific shortcuts
            if (this.activeTab === 'dialer') {
                if (e.key >= '0' && e.key <= '9' || e.key === '*' || e.key === '#') {
                    this.addDigit(e.key);
                } else if (e.key === 'Backspace') {
                    this.removeDigit();
                } else if (e.key === 'Enter') {
                    this.handleEnterKey();
                } else if (e.key === 'Escape') {
                    this.handleEscapeKey();
                }
            }
        });

        // Input field event listeners
        this.dialerInput.addEventListener('input', (e) => {
            this.currentNumber = e.target.value;

            // Stop dial tone when user starts typing
            if (this.currentNumber && this.dialToneOscillator) {
                this.stopDialTone();
            }

            this.updateDisplay();
            this.updateAutoComplete();
        });

        this.dialerInput.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowDown') {
                e.preventDefault();
                this.navigateAutoComplete(1);
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                this.navigateAutoComplete(-1);
            } else if (e.key === 'Enter') {
                e.preventDefault();
                if (this.selectedAutoCompleteIndex >= 0) {
                    this.selectAutoCompleteItem(this.selectedAutoCompleteIndex);
                } else {
                    this.handleEnterKey();
                }
            } else if (e.key === 'Escape') {
                this.hideAutoComplete();
            }
        });

        // SMS button
        this.smsBtn.addEventListener('click', () => this.openSMS());

        // Test DTMF button
        this.testDTMFBtn.addEventListener('click', () => this.testAllDTMFTones());

        // Add Contact button
        this.addContactBtn.addEventListener('click', () => this.addContact());

        // DTMF status toggle
        this.dtmfStatus.addEventListener('click', () => this.toggleDTMF());

        // Intercom controls
        this.sendIntercomBtn.addEventListener('click', () => this.sendIntercom());
        this.intercomMessage.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                this.sendIntercom();
            }
        });

        // Save settings button
        this.saveSettingsBtn.addEventListener('click', () => this.saveAllSettings());

        // P2P Audio Controls
        this.setupP2PEventListeners();

        // Click outside to hide auto-complete
        document.addEventListener('click', (e) => {
            if (!this.dialerInput.contains(e.target) && !this.autoCompleteDropdown.contains(e.target)) {
                this.hideAutoComplete();
            }
        });

        // Provider selection handler
        this.sipProvider.addEventListener('change', () => {
            this.handleProviderChange();
            this.saveSettings();
        });

        // Settings auto-save
        [this.sipServer, this.sipPort, this.sipUsername, this.sipPassword, this.sipDisplayName].forEach(element => {
            element.addEventListener('change', () => this.saveSettings());
        });

        // Enhanced keyboard navigation for all select elements
        document.querySelectorAll('select').forEach(select => {
            this.setupSelectKeyboardNavigation(select);
        });

        // Initialize audio device detection
        this.initializeAudioDevices();
    }

    setupP2PEventListeners() {
        // P2P Mode change handler
        const p2pMode = document.getElementById('p2pMode');
        if (p2pMode) {
            p2pMode.addEventListener('change', () => {
                this.p2pManager.handleConnectionModeChange();
            });
        }

        // P2P Control buttons
        const startP2P = document.getElementById('startP2P');
        if (startP2P) {
            startP2P.addEventListener('click', async () => {
                const mode = document.getElementById('p2pMode').value;
                const isHost = mode === 'host';

                // Update settings from UI
                if (isHost) {
                    this.p2pManager.sessionName = document.getElementById('sessionName').value;
                    this.p2pManager.sessionPassword = document.getElementById('sessionPassword').value;
                } else {
                    this.p2pManager.remoteIP = document.getElementById('remoteIP').value;
                    this.p2pManager.sessionName = document.getElementById('joinSessionName').value;
                    this.p2pManager.sessionPassword = document.getElementById('joinPassword').value;
                }

                this.p2pManager.audioCodec = document.getElementById('audioCodec').value;
                this.p2pManager.bufferSize = parseInt(document.getElementById('bufferSize').value);

                await this.p2pManager.startSession(isHost);
            });
        }

        const stopP2P = document.getElementById('stopP2P');
        if (stopP2P) {
            stopP2P.addEventListener('click', () => {
                this.p2pManager.disconnect();
            });
        }

        // P2P Volume controls
        const p2pInputVolume = document.getElementById('p2pInputVolume');
        if (p2pInputVolume) {
            p2pInputVolume.addEventListener('input', (e) => {
                const value = e.target.value / 100;
                this.p2pManager.adjustVolume('input', value);
                document.getElementById('inputVolumeValue').textContent = e.target.value + '%';
            });
        }

        const p2pOutputVolume = document.getElementById('p2pOutputVolume');
        if (p2pOutputVolume) {
            p2pOutputVolume.addEventListener('input', (e) => {
                const value = e.target.value / 100;
                this.p2pManager.adjustVolume('output', value);
                document.getElementById('outputVolumeValue').textContent = e.target.value + '%';
            });
        }

        // P2P Mute controls
        const muteInput = document.getElementById('muteInput');
        if (muteInput) {
            muteInput.addEventListener('click', () => {
                const isMuted = this.p2pManager.toggleMute('input');
                muteInput.textContent = isMuted ? 'Unmute Mic' : 'Mute Mic';
                this.speakAction(isMuted ? 'Microphone muted' : 'Microphone unmuted');
            });
        }

        const muteOutput = document.getElementById('muteOutput');
        if (muteOutput) {
            muteOutput.addEventListener('click', () => {
                const isMuted = this.p2pManager.toggleMute('output');
                muteOutput.textContent = isMuted ? 'Unmute Audio' : 'Mute Audio';
                this.speakAction(isMuted ? 'Audio muted' : 'Audio unmuted');
            });
        }

        // Reset Audio to Defaults button
        const resetAudioDefaults = document.getElementById('resetAudioDefaults');
        if (resetAudioDefaults) {
            resetAudioDefaults.addEventListener('click', async () => {
                await this.resetAudioToDefaults();
                this.speakAction('Audio reset to defaults');
            });
        }

        // Test Sound button
        const testSound = document.getElementById('testSound');
        if (testSound) {
            testSound.addEventListener('click', async () => {
                await this.playTestSound();
            });
        }

        // Audio Diagnostics button
        const runAudioDiagnostics = document.getElementById('runAudioDiagnostics');
        if (runAudioDiagnostics) {
            runAudioDiagnostics.addEventListener('click', async () => {
                try {
                    this.speakAction('Running comprehensive audio diagnostics');
                    this.showToast('Running audio diagnostics...', 'info');

                    // Clear audio cache first
                    const cacheCleared = await this.clearAudioCache();
                    if (!cacheCleared) {
                        console.warn('âš ï¸ Audio cache clearing failed, continuing with diagnostics');
                    }

                    // Run comprehensive diagnostics
                    await this.runAudioDiagnostics();
                    await this.initializeAudioDevices();

                    // Check if custom audio driver might be needed
                    const needsCustomDriver = this.assessCustomAudioDriverNeeds();

                    let message = `Audio diagnostics completed. Sample rate: ${this.audioConfig?.actualSampleRate || 'unknown'} hertz.`;

                    if (needsCustomDriver) {
                        message += ' Custom audio driver may be recommended for optimal performance.';
                        console.log('ðŸ”§ Custom audio driver assessment: Recommended');
                    }

                    this.speakAction(message);
                    this.showToast('Audio diagnostics completed', 'success');
                } catch (error) {
                    console.error('âŒ Audio diagnostics failed:', error);
                    this.speakAction('Audio diagnostics failed');
                    this.showToast(`Audio diagnostics failed: ${error.message}`, 'error');
                }
            });
        }

        // Audio codec and buffer size changes
        const audioCodec = document.getElementById('audioCodec');
        if (audioCodec) {
            audioCodec.addEventListener('change', (e) => {
                this.p2pManager.audioCodec = e.target.value;
                this.speakAction(`Audio quality changed to ${e.target.selectedOptions[0].text}`);
            });
        }

        const bufferSize = document.getElementById('bufferSize');
        if (bufferSize) {
            bufferSize.addEventListener('change', (e) => {
                this.p2pManager.bufferSize = parseInt(e.target.value);
                this.speakAction(`Buffer size changed to ${e.target.selectedOptions[0].text}`);
            });
        }

        // Global P2P manager reference for UI callbacks
        window.p2pManager = this.p2pManager;

        // VoicePack Settings Event Listeners
        this.setupVoicePackEventListeners();

        // VoicePack ducking controls
        this.setupDuckingControls();

        // Add API connection button for quick connects
        this.addAPIConnectionFeatures();
    }

    setupVoicePackEventListeners() {
        // VoicePack Enable/Disable
        const voicePackEnabled = document.getElementById('voicePackEnabled');
        if (voicePackEnabled) {
            voicePackEnabled.addEventListener('change', (e) => {
                this.voicePack.enabled = e.target.checked;
                this.speakAction(`VoicePack ${e.target.checked ? 'enabled' : 'disabled'}`);
            });
        }

        // VoicePack Volume Control
        const voicePackVolume = document.getElementById('voicePackVolume');
        if (voicePackVolume) {
            voicePackVolume.addEventListener('input', (e) => {
                const volume = e.target.value / 100;
                this.voicePack.setVolume(volume);
                document.getElementById('voicePackVolumeValue').textContent = e.target.value + '%';
            });
        }

        // VoicePack Selection
        const voicePackSelection = document.getElementById('voicePackSelection');
        if (voicePackSelection) {
            voicePackSelection.addEventListener('change', (e) => {
                if (e.target.value === 'disabled') {
                    this.voicePack.enabled = false;
                    document.getElementById('voicePackEnabled').checked = false;
                } else {
                    this.voicePack.currentPack = e.target.value;
                    this.voicePack.enabled = true;
                    document.getElementById('voicePackEnabled').checked = true;
                    this.voicePack.preloadAudioFiles();
                }
                this.speakAction(`VoicePack changed to ${e.target.selectedOptions[0].text}`);
            });
        }

        // Action-specific settings
        this.setupActionAudioSettings();

        // Test VoicePack
        const testVoicePack = document.getElementById('testVoicePack');
        if (testVoicePack) {
            testVoicePack.addEventListener('click', () => {
                this.testVoicePackSounds();
            });
        }

        // Reset VoicePack settings
        const resetVoicePackSettings = document.getElementById('resetVoicePackSettings');
        if (resetVoicePackSettings) {
            resetVoicePackSettings.addEventListener('click', () => {
                this.resetVoicePackToDefaults();
            });
        }
    }

    setupActionAudioSettings() {
        // F1 Settings
        this.setupActionSetting('f1', 'f1_pickup');
        // F2 Settings
        this.setupActionSetting('f2', 'f2_hangup');
        // F3 Settings
        this.setupActionSetting('f3', 'f3_hold');
        // Volume Settings
        this.setupActionSetting('volume', 'f11_volume_down');
        // DTMF Settings
        this.setupActionSetting('dtmf', 'dtmf_digit');
    }

    setupActionSetting(actionPrefix, voicePackKey) {
        const enabledCheckbox = document.getElementById(`${actionPrefix}_enabled`);
        const volumeSlider = document.getElementById(`${actionPrefix}_volume`);
        const volumeValue = document.getElementById(`${actionPrefix}_volume_val`);

        if (enabledCheckbox) {
            enabledCheckbox.addEventListener('change', (e) => {
                this.voicePack.updateActionSetting(voicePackKey, 'enabled', e.target.checked);
            });
        }

        if (volumeSlider && volumeValue) {
            volumeSlider.addEventListener('input', (e) => {
                const volume = e.target.value / 100;
                this.voicePack.updateActionSetting(voicePackKey, 'outputVolume', volume);
                volumeValue.textContent = e.target.value + '%';
            });
        }
    }

    showSoundPackDialog() {
        // Create modal dialog for sound pack selection
        const dialog = document.createElement('div');
        dialog.className = 'sound-pack-dialog';
        dialog.style.cssText = `
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
        `;

        dialog.innerHTML = `
            <div style="
                background: linear-gradient(135deg, #1e1e1e 0%, #2d2d2d 100%);
                border-radius: 8px;
                padding: 24px;
                min-width: 400px;
                max-width: 600px;
                color: white;
                border: 1px solid rgba(255, 255, 255, 0.1);
            ">
                <h3 style="margin: 0 0 20px 0; color: #00bcd4;">ðŸŽµ Select Sound Pack</h3>

                <div style="margin-bottom: 16px;">
                    <label style="display: block; margin-bottom: 8px;">Available Sound Packs:</label>
                    <select id="soundPackSelector" style="
                        width: 100%;
                        padding: 8px;
                        background: #333;
                        color: white;
                        border: 1px solid #555;
                        border-radius: 4px;
                    ">
                        <option value="none">None (Disabled)</option>
                        <option value="default" ${this.voicePack.currentPack === 'default' ? 'selected' : ''}>Default (System Beeps)</option>
                        <option value="VoicePack01" ${this.voicePack.currentPack === 'VoicePack01' ? 'selected' : ''}>VoicePack01 (Voice Prompts)</option>
                    </select>
                </div>

                <div style="margin-bottom: 20px;">
                    <label style="display: block; margin-bottom: 8px;">Preview:</label>
                    <button id="previewSoundPack" style="
                        padding: 8px 16px;
                        background: #00bcd4;
                        color: white;
                        border: none;
                        border-radius: 4px;
                        cursor: pointer;
                    ">ðŸ”Š Play Sample</button>
                </div>

                <div style="display: flex; justify-content: flex-end; gap: 12px;">
                    <button id="cancelSoundPack" style="
                        padding: 8px 16px;
                        background: #666;
                        color: white;
                        border: none;
                        border-radius: 4px;
                        cursor: pointer;
                    ">Cancel</button>
                    <button id="applySoundPack" style="
                        padding: 8px 16px;
                        background: #4caf50;
                        color: white;
                        border: none;
                        border-radius: 4px;
                        cursor: pointer;
                    ">Apply</button>
                </div>
            </div>
        `;

        // Event handlers
        const selector = dialog.querySelector('#soundPackSelector');
        const preview = dialog.querySelector('#previewSoundPack');
        const cancel = dialog.querySelector('#cancelSoundPack');
        const apply = dialog.querySelector('#applySoundPack');

        preview.addEventListener('click', () => {
            const selectedPack = selector.value;
            if (selectedPack === 'none') {
                this.speakAction('No sound pack selected');
            } else {
                // Play a sample from the selected pack
                this.voicePack.playSound('ready');
            }
        });

        cancel.addEventListener('click', () => {
            dialog.remove();
            this.speakAction('Sound pack selection cancelled');
        });

        apply.addEventListener('click', () => {
            const selectedPack = selector.value;

            if (selectedPack === 'none') {
                this.voicePack.enabled = false;
                this.speakAction('VoicePack disabled');
            } else {
                this.voicePack.currentPack = selectedPack;
                this.voicePack.enabled = true;
                this.voicePack.preloadAudioFiles();
                this.speakAction(`VoicePack changed to ${selectedPack}`);
            }

            // Update UI controls
            const voicePackEnabled = document.getElementById('voicePackEnabled');
            const voicePackSelection = document.getElementById('voicePackSelection');

            if (voicePackEnabled) voicePackEnabled.checked = this.voicePack.enabled;
            if (voicePackSelection) voicePackSelection.value = selectedPack === 'none' ? 'disabled' : selectedPack;

            dialog.remove();
        });

        document.body.appendChild(dialog);

        // Focus the selector for keyboard navigation
        selector.focus();

        this.speakAction('Sound pack selection dialog opened');
    }

    async testVoicePackSounds() {
        this.speakAction('Testing VoicePack sounds');

        const testSequence = [
            { action: 'f1_pickup', delay: 1000 },
            { sound: '1', delay: 500 },
            { sound: '2', delay: 500 },
            { sound: '3', delay: 500 },
            { action: 'f2_hangup', delay: 1000 },
            { action: 'f11_volume_down', delay: 800 }
        ];

        for (const test of testSequence) {
            if (test.action) {
                await this.voicePack.playActionSound(test.action);
            } else if (test.sound) {
                await this.voicePack.playSound(test.sound);
            }

            if (test.delay) {
                await new Promise(resolve => setTimeout(resolve, test.delay));
            }
        }

        this.speakAction('VoicePack test completed');
    }

    resetVoicePackToDefaults() {
        // Reset VoicePack to default settings
        this.voicePack.enabled = true;
        this.voicePack.currentPack = 'VoicePack01';
        this.voicePack.volume = 0.8;

        // Reset action settings to defaults
        this.voicePack.actionSettings = {
            'f1_pickup': { enabled: true, sound: 'ready', inputVolume: 0.8, outputVolume: 0.8 },
            'f2_hangup': { enabled: true, sound: 'call_ending', inputVolume: 0.8, outputVolume: 0.8 },
            'f3_hold': { enabled: true, sound: 'not_in_service', inputVolume: 0.6, outputVolume: 0.6 },
            'f11_volume_down': { enabled: true, sound: 'volume_down', inputVolume: 0.7, outputVolume: 0.9 },
            'f12_volume_up': { enabled: true, sound: 'volume_up', inputVolume: 0.7, outputVolume: 0.9 },
            'dtmf_digit': { enabled: true, sound: 'dynamic', inputVolume: 0.8, outputVolume: 0.8 }
        };

        this.voicePack.saveAudioSettings();

        // Update UI
        this.updateVoicePackUI();

        this.speakAction('VoicePack settings reset to defaults');
    }

    updateVoicePackUI() {
        // Update all VoicePack UI elements to reflect current settings
        const voicePackEnabled = document.getElementById('voicePackEnabled');
        const voicePackVolume = document.getElementById('voicePackVolume');
        const voicePackVolumeValue = document.getElementById('voicePackVolumeValue');
        const voicePackSelection = document.getElementById('voicePackSelection');

        if (voicePackEnabled) voicePackEnabled.checked = this.voicePack.enabled;
        if (voicePackVolume) voicePackVolume.value = Math.round(this.voicePack.volume * 100);
        if (voicePackVolumeValue) voicePackVolumeValue.textContent = Math.round(this.voicePack.volume * 100) + '%';
        if (voicePackSelection) voicePackSelection.value = this.voicePack.enabled ? this.voicePack.currentPack : 'disabled';

        // Update action settings
        const actions = ['f1', 'f2', 'f3', 'volume', 'dtmf'];
        actions.forEach(action => {
            const enabledEl = document.getElementById(`${action}_enabled`);
            const volumeEl = document.getElementById(`${action}_volume`);
            const volumeValEl = document.getElementById(`${action}_volume_val`);

            if (enabledEl && this.voicePack.actionSettings[`${action}_pickup`] !== undefined) {
                enabledEl.checked = this.voicePack.actionSettings[`${action}_pickup`].enabled;
            }
        });
    }

    setupDuckingControls() {
        // Initialize ducking settings
        this.duckingSettings = {
            enabled: true,
            level: 0.7, // 70% ducking (30% volume remaining)
            speed: 'medium' // slow, medium, fast
        };

        // Ducking level control
        const duckingLevel = document.getElementById('duckingLevel');
        const duckingLevelValue = document.getElementById('duckingLevelValue');
        if (duckingLevel && duckingLevelValue) {
            duckingLevel.addEventListener('input', (e) => {
                const level = parseInt(e.target.value);
                this.duckingSettings.level = (100 - level) / 100; // Invert: 100% = no ducking (level 0)
                duckingLevelValue.textContent = level + '%';
                this.speakAction(`Ducking level set to ${level} percent`);
            });
        }

        // Ducking speed control
        const duckingSpeed = document.getElementById('duckingSpeed');
        if (duckingSpeed) {
            duckingSpeed.addEventListener('change', (e) => {
                this.duckingSettings.speed = e.target.value;
                this.speakAction(`Ducking speed set to ${e.target.selectedOptions[0].text}`);
            });
        }

        // Enable/disable ducking
        const enableDucking = document.getElementById('enableDucking');
        if (enableDucking) {
            enableDucking.addEventListener('change', (e) => {
                this.duckingSettings.enabled = e.target.checked;
                this.speakAction(`Audio ducking ${e.target.checked ? 'enabled' : 'disabled'}`);
            });
        }

        // Test ducking button
        const testDucking = document.getElementById('testDucking');
        if (testDucking) {
            testDucking.addEventListener('click', () => {
                this.testAudioDucking();
            });
        }
    }

    async testAudioDucking() {
        this.speakAction('Testing audio ducking');

        try {
            // Start a test ringtone
            this.startTestRingtone();

            // Wait 1 second, then test ducking
            setTimeout(async () => {
                await this.testDuckingSequence();
            }, 1000);

        } catch (error) {
            console.error('Failed to test ducking:', error);
        }
    }

    startTestRingtone() {
        // Create a test ringtone for ducking demo
        this.testRingtoneActive = true;
        this.playTestRing();
    }

    playTestRing() {
        if (!this.testRingtoneActive) return;

        try {
            const oscillator = this.audioContext.createOscillator();
            const gainNode = this.audioContext.createGain();

            oscillator.frequency.setValueAtTime(440, this.audioContext.currentTime);
            oscillator.frequency.setValueAtTime(480, this.audioContext.currentTime + 0.4);

            gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
            gainNode.gain.linearRampToValueAtTime(0.2, this.audioContext.currentTime + 0.1);
            gainNode.gain.linearRampToValueAtTime(0, this.audioContext.currentTime + 0.8);

            oscillator.connect(gainNode);
            gainNode.connect(this.audioContext.destination);

            oscillator.start(this.audioContext.currentTime);
            oscillator.stop(this.audioContext.currentTime + 0.8);

            // Continue test ringing
            if (this.testRingtoneActive) {
                setTimeout(() => this.playTestRing(), 3000);
            }

        } catch (error) {
            console.error('Failed to play test ring:', error);
        }
    }

    async testDuckingSequence() {
        // Simulate ducking for caller ID announcement
        const originalVolume = this.outputVolume;

        // Apply ducking
        await this.applyAudioDucking(originalVolume);

        // Announce test number
        await this.voicePack.announcePhoneNumber('5551234567');

        // Restore volume
        await this.restoreAudioVolume(originalVolume);

        // Stop test ringtone after 2 more seconds
        setTimeout(() => {
            this.testRingtoneActive = false;
            this.speakAction('Ducking test completed');
        }, 2000);
    }

    async applyAudioDucking(originalVolume) {
        if (!this.duckingSettings.enabled) return;

        const targetVolume = originalVolume * (1 - this.duckingSettings.level);
        const duration = this.getDuckingDuration();

        // Smoothly reduce volume
        await this.animateVolumeChange(originalVolume, targetVolume, duration);
    }

    async restoreAudioVolume(originalVolume) {
        if (!this.duckingSettings.enabled) return;

        const currentVolume = this.outputVolume;
        const duration = this.getDuckingDuration();

        // Smoothly restore volume
        await this.animateVolumeChange(currentVolume, originalVolume, duration);
    }

    getDuckingDuration() {
        switch (this.duckingSettings.speed) {
            case 'slow': return 2000; // 2 seconds
            case 'fast': return 500;  // 0.5 seconds
            default: return 1000;     // 1 second (medium)
        }
    }

    async animateVolumeChange(fromVolume, toVolume, duration) {
        const steps = 20;
        const stepDuration = duration / steps;
        const volumeStep = (toVolume - fromVolume) / steps;

        for (let i = 0; i <= steps; i++) {
            this.outputVolume = fromVolume + (volumeStep * i);
            await new Promise(resolve => setTimeout(resolve, stepDuration));
        }

        this.outputVolume = toVolume;
    }

    async announceCallerIDWithDucking(phoneNumber) {
        if (!this.isRingtoneActive) return;

        try {
            const originalVolume = this.outputVolume;

            if (this.duckingSettings.enabled) {
                // Apply smooth ducking
                await this.applyAudioDucking(originalVolume);
            }

            // Announce the caller ID
            await this.voicePack.announceCallerID(phoneNumber);

            if (this.duckingSettings.enabled) {
                // Restore volume smoothly
                await this.restoreAudioVolume(originalVolume);
            }

        } catch (error) {
            console.error('Failed to announce caller ID with ducking:', error);
            // Restore volume on error
            this.outputVolume = originalVolume;
        }
    }

    addAPIConnectionFeatures() {
        // Add quick connect API functionality
        const dialerInput = document.getElementById('dialerInput');
        if (dialerInput) {
            // Check if it's an IP address or domain for direct P2P connection
            dialerInput.addEventListener('blur', () => {
                const value = dialerInput.value.trim();
                if (this.isIPAddressOrDomain(value)) {
                    this.suggestP2PConnection(value);
                }
            });
        }
    }

    isIPAddressOrDomain(value) {
        // Check if the input looks like an IP address or domain
        const ipRegex = /^(\d{1,3}\.){3}\d{1,3}$/;
        const domainRegex = /^[a-zA-Z0-9][a-zA-Z0-9-]{1,61}[a-zA-Z0-9]\.[a-zA-Z]{2,}$/;

        return ipRegex.test(value) || domainRegex.test(value);
    }

    suggestP2PConnection(address) {
        // Show suggestion for P2P connection
        const suggestion = document.createElement('div');
        suggestion.className = 'p2p-suggestion';
        suggestion.style.cssText = `
            position: absolute;
            background: rgba(0, 150, 136, 0.9);
            color: white;
            padding: 10px;
            border-radius: 4px;
            font-size: 0.9em;
            z-index: 1000;
            margin-top: 5px;
            cursor: pointer;
        `;
        suggestion.innerHTML = `
            ðŸ’¡ Direct P2P connection available for ${address}<br>
            <small>Click to connect directly without PBX</small>
        `;

        suggestion.addEventListener('click', () => {
            this.initiateDirectP2PConnection(address);
            suggestion.remove();
        });

        // Auto-remove after 5 seconds
        setTimeout(() => {
            if (suggestion.parentNode) {
                suggestion.remove();
            }
        }, 5000);

        // Position near the input
        const dialerContainer = document.querySelector('.dialer-input-section');
        if (dialerContainer) {
            dialerContainer.appendChild(suggestion);
        }

        // Speak the suggestion
        this.speakAction(`Direct P2P connection available for ${address}`);
    }

    async initiateDirectP2PConnection(address) {
        try {
            // Switch to P2P Audio tab
            this.switchTab('p2p-audio');

            // Set to join mode
            const p2pMode = document.getElementById('p2pMode');
            if (p2pMode) {
                p2pMode.value = 'join';
                this.p2pManager.handleConnectionModeChange();
            }

            // Fill in the remote IP
            const remoteIP = document.getElementById('remoteIP');
            if (remoteIP) {
                remoteIP.value = address;
            }

            // Auto-fill session name
            const joinSessionName = document.getElementById('joinSessionName');
            if (joinSessionName) {
                joinSessionName.value = `Direct-${address}`;
            }

            // Show status
            this.p2pManager.updateConnectionStatus(`Ready to connect to ${address}`, 'ready');

            this.speakAction(`P2P connection prepared for ${address}. Click Start Session to connect.`);

        } catch (error) {
            console.error('Failed to initiate direct P2P connection:', error);
            this.speakAction('Failed to prepare P2P connection');
        }
    }

    // Enhanced makeCall to detect P2P vs SIP
    async makeCall() {
        const number = this.currentNumber.trim();

        if (!number) {
            this.speakAction('Please enter a number to call');
            return;
        }

        // Check if it's a direct P2P call (IP address or domain)
        if (this.isIPAddressOrDomain(number)) {
            await this.initiateDirectP2PConnection(number);
            return;
        }

        // Continue with normal SIP call
        this.makeRegularSIPCall();
    }

    makeRegularSIPCall() {
        // Original SIP call logic
        if (!this.isConnected) {
            this.showToast('Not connected to SIP server', 'error');
            return;
        }

        if (!this.currentNumber) {
            this.showToast('Please enter a number to call', 'error');
            return;
        }

        // Add to call history
        const call = {
            id: Date.now(),
            remoteNumber: this.currentNumber,
            direction: 'outgoing',
            status: 'calling',
            startTime: new Date(),
            duration: 0
        };

        this.addCallToHistory(call);

        // Make SIP call
        if (window.flexPhoneAPI) {
            window.flexPhoneAPI.sip.makeCall(this.currentNumber);
            this.currentCall = call;

            // Track call started with PBX
            this.trackCallStarted({
                id: call.id,
                number: this.currentNumber,
                direction: 'outgoing'
            });

            this.speakAction(`Calling ${this.currentNumber}`);
        }
    }

    async initializeAudioDevices() {
        try {
            console.log('ðŸ”Š Initializing audio devices with diagnostics...');

            // Run comprehensive audio diagnostics first
            await this.runAudioDiagnostics();

            // Enhanced audio constraints for built-in devices
            const audioConstraints = {
                audio: {
                    sampleRate: 48000, // Try 48kHz first (common professional standard)
                    channelCount: 2,
                    echoCancellation: true,
                    noiseSuppression: true,
                    autoGainControl: true,
                    // Prefer built-in devices
                    deviceId: { ideal: 'default' }
                }
            };

            // Test different sample rates for compatibility
            let stream = null;
            const supportedSampleRates = [48000, 44100, 22050, 16000];

            for (const sampleRate of supportedSampleRates) {
                try {
                    audioConstraints.audio.sampleRate = sampleRate;
                    console.log(`ðŸŽµ Testing sample rate: ${sampleRate}Hz`);

                    stream = await navigator.mediaDevices.getUserMedia(audioConstraints);

                    // Check actual sample rate achieved
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)({
                        sampleRate: sampleRate
                    });

                    console.log(`âœ… Successfully initialized audio at ${audioContext.sampleRate}Hz (requested: ${sampleRate}Hz)`);

                    if (audioContext.sampleRate !== sampleRate) {
                        console.warn(`âš ï¸ Sample rate mismatch: requested ${sampleRate}Hz, got ${audioContext.sampleRate}Hz`);
                    }

                    // Store successful configuration
                    this.audioConfig = {
                        requestedSampleRate: sampleRate,
                        actualSampleRate: audioContext.sampleRate,
                        compatible: true
                    };

                    audioContext.close();
                    break;

                } catch (error) {
                    console.warn(`âŒ Sample rate ${sampleRate}Hz failed:`, error.message);
                    if (stream) {
                        stream.getTracks().forEach(track => track.stop());
                        stream = null;
                    }
                }
            }

            if (!stream) {
                throw new Error('No compatible sample rate found');
            }

            // Get available audio devices
            const devices = await navigator.mediaDevices.enumerateDevices();

            const audioInputSelect = document.getElementById('audioInputDevice');
            const audioOutputSelect = document.getElementById('audioOutputDevice');

            // Clear existing options
            audioInputSelect.innerHTML = '<option value="">Default Input Device</option>';
            audioOutputSelect.innerHTML = '<option value="">Default Output Device</option>';

            // Filter out loopback devices and add compatible devices
            const compatibleDevices = devices.filter(device => {
                const label = device.label.toLowerCase();
                // Filter out known problematic device types
                const isLoopback = label.includes('loopback') ||
                                  label.includes('blackhole') ||
                                  label.includes('soundflower') ||
                                  label.includes('virtual');

                if (isLoopback) {
                    console.log(`ðŸš« Filtered out loopback/virtual device: ${device.label}`);
                    return false;
                }
                return true;
            });

            // Add detected compatible devices
            compatibleDevices.forEach(device => {
                const option = document.createElement('option');
                option.value = device.deviceId;

                if (device.kind === 'audioinput') {
                    const deviceInfo = this.getDeviceInfo(device);
                    option.text = `${device.label || `Microphone ${audioInputSelect.options.length}`} ${deviceInfo}`;
                    audioInputSelect.appendChild(option);
                } else if (device.kind === 'audiooutput') {
                    const deviceInfo = this.getDeviceInfo(device);
                    option.text = `${device.label || `Speaker ${audioOutputSelect.options.length}`} ${deviceInfo}`;
                    audioOutputSelect.appendChild(option);
                }
            });

            // Add keyboard navigation to audio device selects
            this.setupSelectKeyboardNavigation(audioInputSelect);
            this.setupSelectKeyboardNavigation(audioOutputSelect);

            // Listen for device changes
            navigator.mediaDevices.addEventListener('devicechange', () => {
                this.initializeAudioDevices();
            });

            // Announce current devices and diagnostics
            this.announceAudioDiagnostics(compatibleDevices);

            // Clean up test stream
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
            }

        } catch (error) {
            console.error('âŒ Failed to initialize audio devices:', error);
            // Show error in status display
            const statusDisplay = document.getElementById('statusDisplay');
            if (statusDisplay) {
                statusDisplay.textContent = `Audio initialization failed: ${error.message}`;
                setTimeout(() => {
                    statusDisplay.textContent = 'Ready';
                }, 5000);
            }
        }
    }

    async runAudioDiagnostics() {
        console.log('ðŸ” Running comprehensive audio diagnostics...');

        try {
            // Test AudioContext creation
            const testContext = new (window.AudioContext || window.webkitAudioContext)();
            console.log(`âœ… AudioContext supported: ${testContext.sampleRate}Hz base rate`);
            testContext.close();

            // Test getUserMedia support
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                throw new Error('getUserMedia not supported');
            }
            console.log('âœ… getUserMedia supported');

            // Check available devices before requesting permissions
            const initialDevices = await navigator.mediaDevices.enumerateDevices();
            console.log(`ðŸ“± Found ${initialDevices.length} total devices`);

            const audioInputs = initialDevices.filter(d => d.kind === 'audioinput');
            const audioOutputs = initialDevices.filter(d => d.kind === 'audiooutput');

            console.log(`ðŸŽ¤ Audio inputs: ${audioInputs.length}, ðŸ”Š Audio outputs: ${audioOutputs.length}`);

            // Log device details for debugging
            audioInputs.forEach((device, index) => {
                console.log(`ðŸŽ¤ Input ${index + 1}: ${device.label || 'Unlabeled'} (${device.deviceId.substring(0, 10)}...)`);
            });

            audioOutputs.forEach((device, index) => {
                console.log(`ðŸ”Š Output ${index + 1}: ${device.label || 'Unlabeled'} (${device.deviceId.substring(0, 10)}...)`);
            });

            console.log('âœ… Audio diagnostics completed');

        } catch (error) {
            console.error('âŒ Audio diagnostics failed:', error);
            throw error;
        }
    }

    getDeviceInfo(device) {
        const label = device.label.toLowerCase();

        // Identify device types for better user information
        if (label.includes('built-in') || label.includes('internal')) {
            return '(Built-in)';
        } else if (label.includes('headphone') || label.includes('headset')) {
            return '(Headphones)';
        } else if (label.includes('bluetooth') || label.includes('bt')) {
            return '(Bluetooth)';
        } else if (label.includes('usb')) {
            return '(USB)';
        } else if (label.includes('airpods') || label.includes('beats')) {
            return '(Wireless)';
        }

        return ''; // No additional info for unknown devices
    }

    announceAudioDiagnostics(devices) {
        // Announce comprehensive audio status
        setTimeout(() => {
            const audioInputSelect = document.getElementById('audioInputDevice');
            const audioOutputSelect = document.getElementById('audioOutputDevice');

            if (audioInputSelect && audioOutputSelect) {
                const currentInput = audioInputSelect.options[audioInputSelect.selectedIndex]?.text || 'Default Input Device';
                const currentOutput = audioOutputSelect.options[audioOutputSelect.selectedIndex]?.text || 'Default Output Device';

                const audioInputs = devices.filter(d => d.kind === 'audioinput');
                const audioOutputs = devices.filter(d => d.kind === 'audiooutput');

                let announcement = `Audio initialized successfully. `;

                if (this.audioConfig) {
                    announcement += `Sample rate: ${this.audioConfig.actualSampleRate} hertz. `;
                }

                announcement += `Found ${audioInputs.length} input and ${audioOutputs.length} output devices. `;
                announcement += `Current input: ${currentInput}. Current output: ${currentOutput}.`;

                console.log('ðŸŽ¤ðŸ”ŠðŸ”', announcement);

                // Announce after welcome message completes
                setTimeout(() => {
                    this.speakAction(announcement, { volume: 0.4, rate: 0.9 });
                }, 4000);
            }
        }, 1000);
    }

    assessCustomAudioDriverNeeds() {
        console.log('ðŸ”§ Assessing custom audio driver requirements...');

        let needsCustomDriver = false;
        const issues = [];

        try {
            // Check for sample rate mismatches
            if (this.audioConfig) {
                const requestedRate = this.audioConfig.requestedSampleRate;
                const actualRate = this.audioConfig.actualSampleRate;

                if (requestedRate !== actualRate) {
                    issues.push(`Sample rate mismatch: requested ${requestedRate}Hz, got ${actualRate}Hz`);
                    needsCustomDriver = true;
                }

                // Check for low sample rates that might indicate driver issues
                if (actualRate < 44100) {
                    issues.push(`Low sample rate detected: ${actualRate}Hz`);
                    needsCustomDriver = true;
                }
            }

            // Check for audio initialization failures during startup
            if (!this.audioContext || this.audioContext.state === 'closed') {
                issues.push('AudioContext failed to initialize properly');
                needsCustomDriver = true;
            }

            // Check for lack of audio devices
            const audioDeviceSelects = {
                input: document.getElementById('audioInputDevice'),
                output: document.getElementById('audioOutputDevice')
            };

            Object.entries(audioDeviceSelects).forEach(([type, select]) => {
                if (select && select.options.length <= 1) {
                    issues.push(`No ${type} devices detected`);
                    needsCustomDriver = true;
                }
            });

            // Check platform-specific issues
            const platform = navigator.platform.toLowerCase();
            if (platform.includes('mac')) {
                // macOS-specific checks
                console.log('ðŸŽ macOS audio environment detected');
            } else if (platform.includes('win')) {
                // Windows-specific checks
                console.log('ðŸªŸ Windows audio environment detected');
                // Windows often has more audio driver complexity
                needsCustomDriver = true;
                issues.push('Windows platform detected - custom driver recommended for VoIP optimization');
            } else if (platform.includes('linux')) {
                // Linux-specific checks
                console.log('ðŸ§ Linux audio environment detected');
                needsCustomDriver = true;
                issues.push('Linux platform detected - ALSA/PulseAudio optimization recommended');
            }

            if (issues.length > 0) {
                console.log('ðŸ”§ Custom audio driver issues detected:');
                issues.forEach(issue => console.log(`   âš ï¸ ${issue}`));
            }

            if (needsCustomDriver) {
                console.log('ðŸ”§ Recommendation: Custom audio driver development recommended');
                console.log('ðŸ“‹ Custom driver benefits:');
                console.log('   â€¢ Low-latency audio processing');
                console.log('   â€¢ Sample rate control');
                console.log('   â€¢ Enhanced VoIP codec support');
                console.log('   â€¢ Platform-specific optimizations');
                console.log('   â€¢ Audio device hot-swap handling');
            } else {
                console.log('âœ… Standard audio drivers appear sufficient');
            }

            return needsCustomDriver;

        } catch (error) {
            console.error('âŒ Failed to assess custom audio driver needs:', error);
            return true; // Default to recommending custom driver on error
        }
    }

    announceCurrentDevices(devices) {
        // Announce current input and output devices on startup
        setTimeout(() => {
            const audioInputSelect = document.getElementById('audioInputDevice');
            const audioOutputSelect = document.getElementById('audioOutputDevice');

            if (audioInputSelect && audioOutputSelect) {
                const currentInput = audioInputSelect.options[audioInputSelect.selectedIndex]?.text || 'Default Input Device';
                const currentOutput = audioOutputSelect.options[audioOutputSelect.selectedIndex]?.text || 'Default Output Device';

                const deviceAnnouncement = `Audio devices: Input set to ${currentInput}, Output set to ${currentOutput}`;
                console.log('ðŸŽ¤ðŸ”Š', deviceAnnouncement);

                // Announce after welcome message completes
                setTimeout(() => {
                    this.speakAction(deviceAnnouncement, { volume: 0.4, rate: 0.9 });
                }, 4000);
            }
        }, 1000);
    }

    applyStartupAudioConfig() {
        console.log('ðŸ”Š Applying startup audio configuration: normal volume, unmuted');

        // Ensure output volume is set to normal startup volume (70%)
        this.outputVolume = 0.7;
        this.inputVolume = 0.5;

        // Ensure unmuted on startup
        if (this.autoUnmuteOnStartup) {
            this.outputMuted = false;
            this.inputMuted = false;
        }

        // Apply volume to audio context if available
        if (this.audioContext && this.audioContext.state === 'running') {
            // DTMF volume matches output volume at startup
            this.dtmfVolume = this.outputVolume;
        }

        // Log startup audio state
        console.log(`ðŸŽµ Startup Audio State - Output: ${Math.round(this.outputVolume * 100)}% (muted: ${this.outputMuted}), Input: ${Math.round(this.inputVolume * 100)}% (muted: ${this.inputMuted})`);

        // Announce audio configuration after a delay
        setTimeout(() => {
            if (!this.outputMuted) {
                this.speakAction('Audio ready: Normal volume, unmuted', { volume: this.outputVolume, rate: 1.0 });
            }
        }, 2000);
    }

    async clearAudioCache() {
        console.log('ðŸ§¹ Clearing audio cache...');

        try {
            // Clear any existing AudioContext instances
            if (this.audioContext && this.audioContext.state !== 'closed') {
                await this.audioContext.close();
                console.log('âœ… Closed existing AudioContext');
            }

            // Clear any existing media streams
            if (this.currentStream) {
                this.currentStream.getTracks().forEach(track => {
                    track.stop();
                    console.log('âœ… Stopped media track:', track.kind);
                });
                this.currentStream = null;
            }

            // Clear P2P audio streams if available
            if (this.p2pManager && this.p2pManager.localStream) {
                this.p2pManager.localStream.getTracks().forEach(track => {
                    track.stop();
                    console.log('âœ… Stopped P2P track:', track.kind);
                });
                this.p2pManager.localStream = null;
            }

            // Clear VoicePack audio instances
            if (this.voicePack && this.voicePack.audioContext) {
                await this.voicePack.audioContext.close();
                this.voicePack.audioContext = null;
                console.log('âœ… Cleared VoicePack audio context');
            }

            // Clear DTMF audio nodes
            if (this.dtmfOscillator) {
                this.dtmfOscillator.disconnect();
                this.dtmfOscillator = null;
                console.log('âœ… Cleared DTMF oscillator');
            }

            // Clear any cached audio buffers
            this.audioConfig = null;

            // Force garbage collection hint
            if (window.gc) {
                window.gc();
                console.log('âœ… Forced garbage collection');
            }

            console.log('âœ… Audio cache cleared successfully');
            return true;

        } catch (error) {
            console.error('âŒ Failed to clear audio cache:', error);
            return false;
        }
    }

    async resetAudioToDefaults() {
        console.log('ðŸ”„ Resetting audio to defaults');

        try {
            // Clear audio cache first
            await this.clearAudioCache();
            // Reset to default volumes
            this.outputVolume = 0.7; // 70% default volume
            this.inputVolume = 0.5;  // 50% default volume
            this.dtmfVolume = 0.5;   // 50% default DTMF volume

            // Unmute everything
            this.outputMuted = false;
            this.inputMuted = false;

            // Reset UI controls
            const outputVolumeSlider = document.getElementById('p2pOutputVolume');
            const inputVolumeSlider = document.getElementById('p2pInputVolume');
            const outputVolumeValue = document.getElementById('outputVolumeValue');
            const inputVolumeValue = document.getElementById('inputVolumeValue');
            const muteInputBtn = document.getElementById('muteInput');
            const muteOutputBtn = document.getElementById('muteOutput');

            if (outputVolumeSlider) {
                outputVolumeSlider.value = Math.round(this.outputVolume * 100);
            }
            if (inputVolumeSlider) {
                inputVolumeSlider.value = Math.round(this.inputVolume * 100);
            }
            if (outputVolumeValue) {
                outputVolumeValue.textContent = Math.round(this.outputVolume * 100) + '%';
            }
            if (inputVolumeValue) {
                inputVolumeValue.textContent = Math.round(this.inputVolume * 100) + '%';
            }
            if (muteInputBtn) {
                muteInputBtn.textContent = 'Mute Mic';
            }
            if (muteOutputBtn) {
                muteOutputBtn.textContent = 'Mute Audio';
            }

            // Reinitialize audio devices with defaults
            await this.initializeAudioDevices();

            // Ensure AudioContext is ready
            await this.ensureAudioContextReady();

            console.log('âœ… Audio reset to defaults completed');
            this.showToast('Audio reset to defaults', 'success');

        } catch (error) {
            console.error('âŒ Failed to reset audio to defaults:', error);
            this.showToast('Failed to reset audio', 'error');
        }
    }

    async playTestSound() {
        console.log('ðŸ”Š Playing test sound');

        try {
            // Ensure audio context is ready
            await this.ensureAudioContextReady();

            // Create audio element for test sound
            const audio = new Audio('./assets/Sound-Test.wav');
            audio.volume = this.outputMuted ? 0 : this.outputVolume;

            // Play the test sound
            await audio.play();

            // Announce to screen reader
            this.speakAction('Test sound playing');

            console.log('âœ… Test sound played successfully');
            this.showToast('Test sound played', 'success');

        } catch (error) {
            console.error('âŒ Failed to play test sound:', error);
            this.showToast('Failed to play test sound', 'error');

            // Fallback: play a simple beep tone
            try {
                await this.playDTMFTone('*', 0.5); // Play * tone as fallback
                this.speakAction('Test beep played as fallback');
            } catch (fallbackError) {
                console.error('âŒ Fallback beep also failed:', fallbackError);
            }
        }
    }

    setupIPCListeners() {
        if (window.flexPhoneAPI) {
            // SIP events
            window.flexPhoneAPI.on('sip-connected', (event, data) => {
                this.onSIPConnected(data);
            });

            window.flexPhoneAPI.on('sip-disconnected', (event, data) => {
                this.onSIPDisconnected(data);
            });

            window.flexPhoneAPI.on('incoming-call', (event, call) => {
                this.onIncomingCall(call);
            });

            window.flexPhoneAPI.on('call-answered', (event, call) => {
                this.onCallAnswered(call);
            });

            window.flexPhoneAPI.on('call-ended', (event, call) => {
                this.onCallEnded(call);
            });

            // SMS events
            window.flexPhoneAPI.on('sms-received', (event, message) => {
                this.onSMSReceived(message);
            });

            // Menu events
            window.flexPhoneAPI.on('show-dialer', () => this.switchTab('dialer'));
            window.flexPhoneAPI.on('show-contacts', () => this.switchTab('contacts'));
            window.flexPhoneAPI.on('show-history', () => this.switchTab('history'));
            window.flexPhoneAPI.on('show-sms', () => this.switchTab('messages'));
            window.flexPhoneAPI.on('show-settings', () => this.switchTab('settings'));
        }
    }

    addDigit(digit) {
        this.currentNumber += digit;
        this.dialerInput.value = this.currentNumber;
        this.updateDisplay();

        // Play local DTMF tone for audible feedback
        this.playDTMFTone(digit);

        // Play VoicePack DTMF voice
        this.voicePack.playDTMFVoice(digit);

        // Send DTMF if connected and on a call
        if (this.isConnected && this.currentCall) {
            window.flexPhoneAPI.sip.sendDTMF(digit);
        }

        // Update auto-complete
        this.updateAutoComplete();
    }

    async playDTMFTone(digit) {
        if (!this.dtmfEnabled || !this.audioContext) {
            return false;
        }

        const frequencies = this.dtmfFrequencies[digit.toString()];
        if (!frequencies) {
            console.log(`âš ï¸ Invalid DTMF digit: ${digit}`);
            return false;
        }

        try {
            // Resume AudioContext if suspended
            if (this.audioContext.state === 'suspended') {
                await this.audioContext.resume();
            }

            // Visual feedback
            this.dtmfStatus.classList.add('playing');
            setTimeout(() => {
                this.dtmfStatus.classList.remove('playing');
            }, this.dtmfDuration);

            // Create oscillators for the two DTMF frequencies
            const oscillator1 = this.audioContext.createOscillator();
            const oscillator2 = this.audioContext.createOscillator();
            const gainNode = this.audioContext.createGain();

            // Set frequencies
            oscillator1.frequency.setValueAtTime(frequencies[0], this.audioContext.currentTime);
            oscillator2.frequency.setValueAtTime(frequencies[1], this.audioContext.currentTime);

            // Set waveform
            oscillator1.type = 'sine';
            oscillator2.type = 'sine';

            // Connect oscillators to gain node
            oscillator1.connect(gainNode);
            oscillator2.connect(gainNode);

            // Set volume with envelope
            const fadeTime = 0.01;
            gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
            gainNode.gain.linearRampToValueAtTime(this.dtmfVolume * this.outputVolume, this.audioContext.currentTime + fadeTime);
            gainNode.gain.linearRampToValueAtTime(this.dtmfVolume, this.audioContext.currentTime + this.dtmfDuration / 1000 - fadeTime);
            gainNode.gain.linearRampToValueAtTime(0, this.audioContext.currentTime + this.dtmfDuration / 1000);

            // Connect to output
            gainNode.connect(this.audioContext.destination);

            // Start and stop oscillators
            const startTime = this.audioContext.currentTime;
            const stopTime = startTime + this.dtmfDuration / 1000;

            oscillator1.start(startTime);
            oscillator2.start(startTime);
            oscillator1.stop(stopTime);
            oscillator2.stop(stopTime);

            console.log(`ðŸŽµ DTMF tone played: ${digit} (${frequencies[0]}Hz + ${frequencies[1]}Hz)`);
            return true;

        } catch (error) {
            console.error(`âŒ Failed to play DTMF tone for ${digit}:`, error);
            return false;
        }
    }

    removeDigit() {
        this.currentNumber = this.currentNumber.slice(0, -1);
        this.updateDisplay();
    }

    clearDisplay() {
        this.currentNumber = '';
        this.dialerInput.value = '';
        this.updateDisplay();
        this.hideAutoComplete();
    }

    updateDisplay() {
        if (this.currentNumber) {
            this.dialerDisplay.textContent = this.formatPhoneNumber(this.currentNumber);
        } else {
            this.dialerDisplay.textContent = 'Enter number...';
        }
    }

    formatPhoneNumber(number) {
        // Simple US phone number formatting
        const cleaned = number.replace(/\D/g, '');
        if (cleaned.length === 10) {
            return `(${cleaned.substr(0, 3)}) ${cleaned.substr(3, 3)}-${cleaned.substr(6, 4)}`;
        } else if (cleaned.length === 11 && cleaned.startsWith('1')) {
            return `+1 (${cleaned.substr(1, 3)}) ${cleaned.substr(4, 3)}-${cleaned.substr(7, 4)}`;
        }
        return number;
    }

    playActionTone(frequency, duration = 150, type = 'single') {
        // Play landline-style action confirmation tones
        if (!this.audioContext) return;

        try {
            if (this.audioContext.state === 'suspended') {
                this.audioContext.resume();
            }

            if (type === 'pickup') {
                // Classic pickup tone: rising frequency
                this.playToneSequence([
                    { freq: 400, duration: 50 },
                    { freq: 600, duration: 50 },
                    { freq: 800, duration: 100 }
                ]);
            } else if (type === 'hangup') {
                // Classic hangup tone: descending frequency
                this.playToneSequence([
                    { freq: 480, duration: 100 },
                    { freq: 350, duration: 100 },
                    { freq: 280, duration: 150 }
                ]);
            } else {
                // Single tone for other actions
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();

                oscillator.frequency.setValueAtTime(frequency, this.audioContext.currentTime);
                oscillator.type = 'square'; // More authentic landline sound

                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);

                // Telephone-style envelope
                gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                gainNode.gain.linearRampToValueAtTime(this.outputVolume * 0.4, this.audioContext.currentTime + 0.005);
                gainNode.gain.linearRampToValueAtTime(0, this.audioContext.currentTime + duration / 1000);

                oscillator.start(this.audioContext.currentTime);
                oscillator.stop(this.audioContext.currentTime + duration / 1000);
            }

        } catch (error) {
            console.error('Failed to play action tone:', error);
        }
    }

    playToneSequence(tones) {
        let startTime = this.audioContext.currentTime;

        tones.forEach(({ freq, duration }) => {
            const oscillator = this.audioContext.createOscillator();
            const gainNode = this.audioContext.createGain();

            oscillator.frequency.setValueAtTime(freq, startTime);
            oscillator.type = 'square';

            oscillator.connect(gainNode);
            gainNode.connect(this.audioContext.destination);

            gainNode.gain.setValueAtTime(0, startTime);
            gainNode.gain.linearRampToValueAtTime(this.outputVolume * 0.3, startTime + 0.005);
            gainNode.gain.linearRampToValueAtTime(0, startTime + duration / 1000);

            oscillator.start(startTime);
            oscillator.stop(startTime + duration / 1000);

            startTime += duration / 1000;
        });
    }

    loadVoices() {
        if (!this.speechSynthesis) return;
        this.voices = this.speechSynthesis.getVoices();

        if (!this.currentVoice && this.voices.length > 0) {
            // Try to find a good default voice
            const preferredVoice = this.voices.find(voice =>
                voice.lang.startsWith('en') && voice.localService
            ) || this.voices[0];
            this.currentVoice = preferredVoice.name;
        }
    }

    speakAction(text) {
        if (!this.speechEnabled || !this.speechSynthesis) return;
        if (this.preferScreenReader) return; // Let screen reader handle it

        try {
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.rate = this.speechRate || 1.2;
            utterance.pitch = this.speechPitch || 1.0;
            utterance.volume = this.speechVolume || 0.8;

            if (this.currentVoice && this.voices.length > 0) {
                const selectedVoice = this.voices.find(voice => voice.name === this.currentVoice);
                if (selectedVoice) {
                    utterance.voice = selectedVoice;
                }
            }

            this.speechSynthesis.speak(utterance);
        } catch (error) {
            console.error('Speech synthesis error:', error);
        }
    }

    handleSpeechControls(e) {
        // Ctrl+Shift speech control layer
        if ((e.ctrlKey || e.metaKey) && e.shiftKey) {
            e.preventDefault();

            switch (e.key.toLowerCase()) {
                case 'f': // Ctrl+Shift+F - Announce all function keys
                    this.announceAllFunctionKeys();
                    return true;

                case 'r': // Ctrl+Shift+R - Adjust speech rate
                    this.adjustSpeechRate();
                    return true;

                case 'v': // Ctrl+Shift+V - Cycle voice
                    this.cycleVoice();
                    return true;

                case 'p': // Ctrl+Shift+P - Adjust speech pitch
                    this.adjustSpeechPitch();
                    return true;

                case 's': // Ctrl+Shift+S - Toggle speech synthesis vs screen reader
                    this.toggleSpeechMode();
                    return true;

                case 't': // Ctrl+Shift+T - Test speech
                    this.testSpeech();
                    return true;

                case '1': case '2': case '3': case '4': case '5':
                case '6': case '7': case '8': case '9': case '0':
                    // Ctrl+Shift+Number - Adjust speech volume (0-9 = 0%-90%)
                    const volume = e.key === '0' ? 1.0 : parseInt(e.key) / 10;
                    this.setSpeechVolume(volume);
                    return true;

                default:
                    return false;
            }
        }
        return false;
    }

    announceAllFunctionKeys() {
        const functionKeyMap = {
            'F1': 'Pickup Phone or Answer Call',
            'F2': 'Hang Up Call',
            'F3': 'Hold or Unhold Current Call',
            'F4': 'Initiate Call Transfer',
            'F5': 'Start or Stop Call Recording',
            'F6': 'Reserved for Future Features',
            'F7': 'Reserved for Future Features',
            'F8': 'Reserved for Future Features',
            'F9': 'Reserved for Future Features',
            'F10': 'Reserved for Future Features',
            'F11': 'Output Volume Down',
            'F12': 'Output Volume Up',
            'Shift F11': 'Input Volume Down - Microphone',
            'Shift F12': 'Input Volume Up - Microphone'
        };

        let announcement = "Function Key Assignments: ";
        const assignments = [];

        for (const [key, description] of Object.entries(functionKeyMap)) {
            if (!description.includes('Reserved')) {
                assignments.push(`${key}: ${description}`);
            }
        }

        announcement += assignments.join('. ') + '. ';

        const reservedKeys = Object.entries(functionKeyMap)
            .filter(([key, desc]) => desc.includes('Reserved'))
            .map(([key]) => key);

        if (reservedKeys.length > 0) {
            announcement += `${reservedKeys.join(', ')} are reserved for future features.`;
        }

        this.speakAction(announcement);
    }

    adjustSpeechRate() {
        const rates = [0.5, 0.8, 1.0, 1.2, 1.5, 2.0];
        const currentIndex = rates.findIndex(rate => Math.abs(rate - (this.speechRate || 1.0)) < 0.1);
        const nextIndex = (currentIndex + 1) % rates.length;
        this.speechRate = rates[nextIndex];

        this.speakAction(`Speech rate set to ${this.speechRate === 1.0 ? 'normal' :
                         this.speechRate < 1.0 ? 'slow' : 'fast'} ${this.speechRate}`);
    }

    cycleVoice() {
        if (!this.voices || this.voices.length === 0) {
            this.speakAction("No voices available");
            return;
        }

        const currentIndex = this.voices.findIndex(voice => voice.name === this.currentVoice);
        const nextIndex = (currentIndex + 1) % this.voices.length;
        this.currentVoice = this.voices[nextIndex].name;

        this.speakAction(`Voice changed to ${this.voices[nextIndex].name}`);
    }

    adjustSpeechPitch() {
        const pitches = [0.5, 0.8, 1.0, 1.2, 1.5];
        const currentIndex = pitches.findIndex(pitch => Math.abs(pitch - (this.speechPitch || 1.0)) < 0.1);
        const nextIndex = (currentIndex + 1) % pitches.length;
        this.speechPitch = pitches[nextIndex];

        this.speakAction(`Speech pitch set to ${this.speechPitch === 1.0 ? 'normal' :
                         this.speechPitch < 1.0 ? 'low' : 'high'} ${this.speechPitch}`);
    }

    toggleSpeechMode() {
        this.preferScreenReader = !this.preferScreenReader;
        this.speakAction(`Speech mode: ${this.preferScreenReader ? 'Screen Reader' : 'Built-in Speech'}`);
    }

    testSpeech() {
        this.speakAction("FlexPhone speech synthesis test. This is a test of the speech system.");
    }

    setSpeechVolume(volume) {
        this.speechVolume = volume;
        this.speakAction(`Speech volume set to ${Math.round(volume * 100)} percent`);
    }

    checkUnsupportedModifiers(fNumber, isShift, isCtrl, isAlt, keyName) {
        // Check for unsupported modifier combinations and announce them
        let modifierText = '';
        let hasUnsupportedCombination = false;

        // Build modifier description
        if (isCtrl && isShift) {
            modifierText = 'Control+Shift+';
            hasUnsupportedCombination = true;
        } else if (isCtrl && isAlt) {
            modifierText = 'Control+Alt+';
            hasUnsupportedCombination = true;
        } else if (isShift && isAlt) {
            modifierText = 'Shift+Alt+';
            hasUnsupportedCombination = true;
        } else if (isCtrl && isShift && isAlt) {
            modifierText = 'Control+Shift+Alt+';
            hasUnsupportedCombination = true;
        } else if (isCtrl && !isShift && !isAlt) {
            // Plain Ctrl+F keys are generally unsupported except for specific cases
            modifierText = 'Control+';
            hasUnsupportedCombination = true;
        } else if (isAlt && !isShift && !isCtrl) {
            // Plain Alt+F keys are generally unsupported
            modifierText = 'Alt+';
            hasUnsupportedCombination = true;
        }

        if (hasUnsupportedCombination) {
            this.showToast(`${modifierText}${keyName} not assigned`, 'info');
            this.speakAction(`${modifierText}${keyName} has no action assigned`);
            this.playActionTone(200, 50); // Short low tone for unassigned keys
            return true;
        }

        return false;
    }

    handleFunctionKeys(e) {
        // Handle F1-F12 function keys
        if (e.key.startsWith('F') && e.key.length <= 3) {
            e.preventDefault();

            const fNumber = parseInt(e.key.substring(1));
            const isShift = e.shiftKey;
            const isCtrl = e.ctrlKey || e.metaKey;
            const isAlt = e.altKey;

            // Check for unsupported modifier combinations first
            if (this.checkUnsupportedModifiers(fNumber, isShift, isCtrl, isAlt, e.key)) {
                return true; // Handled by announcing it's not supported
            }

            switch (fNumber) {
                case 1: // F1 - Pickup phone/Answer call
                    if (isShift) {
                        // Shift+F1 - Sound pack selection dialog
                        this.showSoundPackDialog();
                    } else {
                        // Ensure audio context is ready before pickup
                        this.ensureAudioContextReady().then(async () => {
                            this.playActionTone(0, 0, 'pickup'); // Classic pickup sequence
                            this.voicePack.playF1Pickup(); // VoicePack audio
                            if (this.currentCall && this.currentCall.incoming) {
                                this.speakAction('Answering call');
                                this.answerCall();
                            } else if (!this.phoneOffHook) {
                                this.speakAction('Phone pickup');
                                await this.pickupPhone(true); // true = from F1 key
                            }
                        });
                        this.showToast('F1: Pickup/Answer', 'info');
                    }
                    break;

                case 2: // F2 - Hang up / Shift+F2 - Input device picker
                    if (isShift) {
                        // Shift+F2 - Input audio device picker
                        this.showInputDevicePicker();
                    } else {
                        // F2 - Hang up (or cancel attended transfer if in progress)
                        if (this.inAttendedTransfer) {
                            this.cancelAttendedTransfer();
                        } else {
                            this.playActionTone(0, 0, 'hangup'); // Classic hangup sequence
                            this.voicePack.playF2Hangup(); // VoicePack audio
                            this.speakAction('Hang up');
                            if (this.currentCall) {
                                this.hangupCall();
                            } else if (this.phoneOffHook) {
                                this.hangupPhone();
                            }
                            this.showToast('F2: Hang up', 'info');
                        }
                    }
                    break;

                case 3: // F3 - Contacts Manager / Shift+F3 - Output device selector
                    if (isShift) {
                        // Shift+F3 - Output audio device selector
                        this.showOutputDevicePicker();
                    } else {
                        // F3 - Open Contacts Manager
                        this.speakAction('Contacts manager');
                        this.switchToTab('contacts');
                        this.showToast('F3: Contacts', 'info');
                    }
                    break;

                case 4: // F4 - Call transfer / Shift+F4 - Mute/Unmute input
                    if (isShift) {
                        // Shift+F4 - Mute/Unmute input microphone
                        this.toggleInputMute();
                    } else {
                        // F4 - Call transfer (or complete attended transfer if in progress)
                        if (this.inAttendedTransfer) {
                            this.completeAttendedTransfer();
                        } else {
                            this.playActionTone(700, 150); // Transfer tone
                            this.initiateTransfer();
                        }
                    }
                    break;

                case 5: // F5 - Record start/stop / Shift+F5 - Hold toggle with music
                    if (isShift) {
                        // Shift+F5 - Hold toggle with music/silence for caller
                        this.toggleHoldWithMusic();
                    } else {
                        this.playActionTone(900, 100); // Record tone
                        this.toggleRecording();
                    }
                    break;

                case 6: // F6 - Hold/Unhold / Shift+F6 - Call transfer
                    if (isShift) {
                        // Shift+F6 - Call transfer to extension or phone number
                        this.initiateCallTransfer();
                    } else {
                        // F6 - Standard hold/unhold
                        this.playActionTone(600, 100); // Mid hold tone
                        this.voicePack.playF3Hold(); // VoicePack audio
                        this.toggleHold();
                    }
                    break;

                case 7: // F7 - Queue Login/Logout / Shift+F7 - Conference call
                    if (isShift) {
                        // Shift+F7 - Add someone to call as conference
                        this.initiateConferenceCall();
                    } else {
                        // F7 - Queue Login/Logout (only available for FlexPBX)
                        this.toggleQueueStatus();
                    }
                    break;

                case 8: // F8 - Reserved / Shift+F8 - Quiet exit from conference
                    if (isShift) {
                        // Shift+F8 - Quietly exit call leaving others connected
                        this.quietExitConference();
                    } else {
                        this.playActionTone(500, 100); // Reserved tone
                        this.showToast('F8: Reserved', 'info');
                    }
                    break;

                case 9: // F9 - SMS / Shift+F9 - History
                    if (isShift) {
                        // Shift+F9 - Show call history
                        this.showCallHistory();
                    } else {
                        // F9 - SMS messaging
                        this.showSMSInterface();
                    }
                    break;

                case 10: // F10 - Ringtone toggle / Shift+F10 - Do Not Disturb
                    if (isShift) {
                        // Shift+F10 - Toggle Do Not Disturb mode
                        this.toggleDoNotDisturb();
                    } else {
                        // F10 - Toggle ringtone playback (silent/audible)
                        this.toggleRingtonePlayback();
                    }
                    break;

                case 11: // F11/Shift+F11 - Volume control
                    if (isShift) {
                        this.playActionTone(300, 80); // Low input volume tone
                        this.adjustInputVolume(-0.1); // Shift+F11: Input volume down
                    } else {
                        this.playActionTone(250, 80); // Lower output volume tone
                        this.voicePack.playVolumeChange('down'); // VoicePack audio
                        this.adjustOutputVolume(-0.1); // F11: Output volume down
                    }
                    break;

                case 12: // F12/Shift+F12 - Volume control
                    if (isShift) {
                        this.playActionTone(450, 80); // Higher input volume tone
                        this.adjustInputVolume(0.1); // Shift+F12: Input volume up
                    } else {
                        this.playActionTone(350, 80); // Higher output volume tone
                        this.voicePack.playVolumeChange('up'); // VoicePack audio
                        this.adjustOutputVolume(0.1); // F12: Output volume up
                    }
                    break;

                default:
                    return false; // Not handled
            }
            return true; // Handled
        }
        return false; // Not a function key
    }

    handleTestToneKeys(e) {
        // Handle ` (backtick) and ~ (tilde) keys
        if (e.key === '`' || e.key === '~') {
            e.preventDefault();

            if (e.key === '`' && !e.shiftKey) {
                // Backtick (`) - Auto answer toggle
                this.toggleAutoAnswer();
                return true;
            } else if (e.key === '~' || (e.key === '`' && e.shiftKey)) {
                // Tilde (~) or Shift+Backtick - Play test tones
                this.playTestTones();
                return true;
            }
        }
        return false; // Not handled
    }

    handleEnterKey() {
        // Special behavior: If there's an active call and Enter is pressed
        if (this.currentCall && !this.currentNumber.trim()) {
            // Put current call on hold and prepare for second call
            this.holdCurrentCallForSecondCall();
            return;
        }

        if (this.currentNumber && this.currentNumber.trim()) {
            // If there's a number, check if we should merge with held call
            if (this.pbxCallStates.heldCalls.length > 0) {
                this.makeCallAndMerge();
            } else {
                // Normal call
                this.makeCall();
            }
        } else {
            // If no number, handle pickup/hangup
            if (this.phoneOffHook) {
                this.hangupPhone();
            } else {
                // Ensure audio context is ready before pickup
                this.ensureAudioContextReady().then(async () => {
                    await this.pickupPhone(true); // true = from Enter key
                });
            }
        }
    }

    async pickupPhone(withDialTone = false) {
        this.phoneOffHook = true;

        // Only start dial tone for F1/Enter pickup, not for test tones
        if (withDialTone) {
            await this.startDialTone();
        }

        this.showToast('Phone picked up - ready to dial', 'info');

        // Update visual state
        this.callBtn.style.display = 'none';
        this.hangupBtn.style.display = 'inline-block';
        this.hangupBtn.textContent = 'Hang Up';
    }

    hangupPhone() {
        this.phoneOffHook = false;
        this.stopDialTone();
        this.showToast('Phone hung up', 'info');

        // Update visual state
        this.callBtn.style.display = 'inline-block';
        this.hangupBtn.style.display = 'none';

        // Clear any current call
        if (this.currentCall) {
            this.hangupCall();
        }
    }

    async startDialTone() {
        if (this.dialToneOscillator) return; // Already playing

        try {
            // Ensure audio context is ready
            await this.ensureAudioContextReady();
            if (!this.audioContext) {
                console.warn('âš ï¸ AudioContext not available for dial tone');
                return;
            }

            // Create dual-tone dial tone (350Hz + 440Hz)
            const oscillator1 = this.audioContext.createOscillator();
            const oscillator2 = this.audioContext.createOscillator();
            const gainNode = this.audioContext.createGain();

            // Set dial tone frequencies
            oscillator1.frequency.setValueAtTime(350, this.audioContext.currentTime);
            oscillator2.frequency.setValueAtTime(440, this.audioContext.currentTime);

            // Set waveform
            oscillator1.type = 'sine';
            oscillator2.type = 'sine';

            // Connect oscillators to gain node
            oscillator1.connect(gainNode);
            oscillator2.connect(gainNode);
            gainNode.connect(this.audioContext.destination);

            // Set volume (lower than DTMF, using output volume)
            gainNode.gain.setValueAtTime(this.outputVolume * 0.5, this.audioContext.currentTime);

            // Start oscillators
            oscillator1.start();
            oscillator2.start();

            // Store reference to stop later
            this.dialToneOscillator = { oscillator1, oscillator2, gainNode };

            console.log('ðŸŽµ Dial tone started (350Hz + 440Hz)');

        } catch (error) {
            console.error('âŒ Failed to start dial tone:', error);
        }
    }

    stopDialTone() {
        if (this.dialToneOscillator) {
            try {
                this.dialToneOscillator.oscillator1.stop();
                this.dialToneOscillator.oscillator2.stop();
                this.dialToneOscillator = null;
                console.log('ðŸŽµ Dial tone stopped');
            } catch (error) {
                console.error('âŒ Failed to stop dial tone:', error);
            }
        }
    }

    async makeCall() {
        if (!this.currentNumber) {
            // Don't show error if phone is off-hook (they might be about to dial)
            if (!this.phoneOffHook) {
                this.showToast('Enter a number to call', 'warning');
            }
            return;
        }

        if (!this.isConnected) {
            this.showToast('Connect to SIP server first', 'error');
            return;
        }

        // Stop dial tone when making call
        this.stopDialTone();

        try {
            const result = await window.flexPhoneAPI.sip.makeCall(this.currentNumber);
            if (result.success) {
                this.currentCall = result.callId;
                this.phoneOffHook = false; // Reset pickup state
                this.callBtn.style.display = 'none';
                this.hangupBtn.style.display = 'inline-block';
                this.showToast(`Calling ${this.currentNumber}...`, 'info');
            } else {
                this.showToast(`Call failed: ${result.error}`, 'error');
            }
        } catch (error) {
            this.showToast(`Call error: ${error.message}`, 'error');
        }
    }

    // F-key supporting methods
    toggleHold() {
        if (!this.currentCall) {
            this.showToast('No active call to hold', 'warning');
            this.speakAction('No active call to hold');
            return;
        }

        this.callOnHold = !this.callOnHold;
        if (this.callOnHold) {
            this.showToast('F3: Call on hold', 'info');
            this.speakAction('Call on hold');

            // Check if monitoring is enabled
            if (this.callMonitoringEnabled) {
                this.speakAction('Call monitoring active - you can hear the other party');
                this.showToast('Call monitoring active', 'warning');
            } else {
                this.speakAction('Call audio muted while on hold');
            }

            // TODO: Implement SIP hold functionality
            // For now, simulate hold with or without monitoring
            this.applyHoldMonitoring();

        } else {
            this.showToast('F3: Call resumed', 'info');
            this.speakAction('Call resumed');

            // TODO: Implement SIP unhold functionality
            this.removeHoldMonitoring();
        }
    }

    applyHoldMonitoring() {
        // Apply hold with optional monitoring
        if (this.currentCall && this.currentCall.remoteStream) {
            const audioTracks = this.currentCall.remoteStream.getAudioTracks();

            audioTracks.forEach(track => {
                // If monitoring is enabled, keep remote audio active but at low volume
                // If monitoring is disabled, mute remote audio completely
                if (this.callMonitoringEnabled) {
                    // Reduce volume but keep audio active for monitoring
                    track.enabled = true;
                    // TODO: Implement volume reduction in actual WebRTC implementation
                } else {
                    // Standard hold - mute remote audio
                    track.enabled = false;
                }
            });
        }
    }

    removeHoldMonitoring() {
        // Resume normal call audio
        if (this.currentCall && this.currentCall.remoteStream) {
            const audioTracks = this.currentCall.remoteStream.getAudioTracks();

            audioTracks.forEach(track => {
                track.enabled = true;
            });
        }
    }

    initiateTransfer() {
        if (!this.currentCall) {
            this.showToast('No active call to transfer', 'warning');
            return;
        }

        this.showToast('F4: Call transfer initiated', 'info');
        // TODO: Implement call transfer functionality
    }

    toggleRecording() {
        // First check if there's an active call
        if (!this.currentCall) {
            this.showToast('No active call to record', 'warning');
            this.speakAction('Cannot record - no active call');
            return;
        }

        // Check if recorder tab exists and is available
        const recorderTab = document.querySelector('[data-tab="recorder"]');
        if (!recorderTab) {
            this.showToast('Recording not available', 'warning');
            this.speakAction('Recording feature not available');
            return;
        }

        const recordBtn = document.getElementById('startRecordingBtn');
        if (recordBtn) {
            // Determine if recording is starting or stopping
            const isRecording = this.pbxCallStates.recordingActive;

            recordBtn.click();

            // Track recording state change with PBX
            if (!isRecording) {
                this.trackRecordingStarted();
                this.speakAction('Call recording started');
                this.showToast('F5: Recording started', 'success');
            } else {
                this.trackRecordingStopped();
                this.speakAction('Call recording stopped');
                this.showToast('F5: Recording stopped', 'info');
            }
        } else {
            this.showToast('Recording controls not found', 'warning');
            this.speakAction('Recording controls not available');
        }
    }

    // Advanced Shift+F key functions

    showInputDevicePicker() {
        // Shift+F2 - Input audio device picker
        this.speakAction('Input device picker');

        navigator.mediaDevices.enumerateDevices()
            .then(devices => {
                const audioInputs = devices.filter(device => device.kind === 'audioinput');

                if (audioInputs.length === 0) {
                    this.showToast('No input devices found', 'warning');
                    this.speakAction('No input devices available');
                    return;
                }

                this.showDevicePickerDialog('input', audioInputs);
            })
            .catch(error => {
                console.error('Failed to enumerate input devices:', error);
                this.showToast('Failed to get input devices', 'error');
                this.speakAction('Error accessing input devices');
            });
    }

    showOutputDevicePicker() {
        // Shift+F3 - Output audio device selector
        this.speakAction('Output device picker');

        navigator.mediaDevices.enumerateDevices()
            .then(devices => {
                const audioOutputs = devices.filter(device => device.kind === 'audiooutput');

                if (audioOutputs.length === 0) {
                    this.showToast('No output devices found', 'warning');
                    this.speakAction('No output devices available');
                    return;
                }

                this.showDevicePickerDialog('output', audioOutputs);
            })
            .catch(error => {
                console.error('Failed to enumerate output devices:', error);
                this.showToast('Failed to get output devices', 'error');
                this.speakAction('Error accessing output devices');
            });
    }

    toggleInputMute() {
        // Shift+F4 - Mute/Unmute input microphone
        if (!this.currentCall) {
            this.showToast('No active call to mute', 'warning');
            this.speakAction('No active call - cannot mute microphone');
            return;
        }

        // Toggle mute state
        this.inputMuted = !this.inputMuted;

        // Apply mute to current call/stream
        if (this.currentCall && this.currentCall.localStream) {
            const audioTracks = this.currentCall.localStream.getAudioTracks();
            audioTracks.forEach(track => {
                track.enabled = !this.inputMuted;
            });
        }

        const muteStatus = this.inputMuted ? 'muted' : 'unmuted';
        this.showToast(`Microphone ${muteStatus}`, 'info');
        this.speakAction(`Microphone ${muteStatus}`);

        // Play VoicePack audio if enabled
        this.voicePack.playMuteToggle(this.inputMuted);
    }

    toggleHoldWithMusic() {
        // Shift+F5 - Hold toggle with music/silence for caller
        if (!this.currentCall) {
            this.showToast('No active call to put on hold', 'warning');
            this.speakAction('No active call - cannot use hold with music');
            return;
        }

        this.callOnHoldWithMusic = !this.callOnHoldWithMusic;

        if (this.callOnHoldWithMusic) {
            // Put call on hold with music for caller
            this.startHoldMusic();
            this.showToast('Call on hold with music', 'info');
            this.speakAction('Call on hold with music - you can speak privately');
        } else {
            // Resume normal call
            this.stopHoldMusic();
            this.showToast('Call resumed', 'info');
            this.speakAction('Call resumed');
        }

        // Play VoicePack audio
        this.voicePack.playHoldToggle(this.callOnHoldWithMusic);
    }

    initiateCallTransfer() {
        // Shift+F6 - Call transfer to extension or phone number
        if (!this.currentCall) {
            this.showToast('No active call to transfer', 'warning');
            this.speakAction('No active call - cannot transfer');
            return;
        }

        this.speakAction('Call transfer');
        this.showTransferDialog();
    }

    initiateConferenceCall() {
        // Shift+F7 - Add someone to call as conference
        if (!this.currentCall) {
            this.showToast('No active call for conference', 'warning');
            this.speakAction('No active call - cannot start conference');
            return;
        }

        this.speakAction('Conference call setup');
        this.showConferenceDialog();
    }

    quietExitConference() {
        // Shift+F8 - Quietly exit call leaving others connected
        if (!this.currentCall || !this.isInConference) {
            this.showToast('Not in a conference call', 'warning');
            this.speakAction('Not in conference call');
            return;
        }

        this.speakAction('Quietly leaving conference');

        // Leave conference without hanging up for others
        this.leaveConferenceQuietly()
            .then(() => {
                this.showToast('Left conference quietly', 'info');
                this.speakAction('Left conference - others remain connected');
            })
            .catch(error => {
                this.showToast('Failed to leave conference', 'error');
                this.speakAction('Error leaving conference');
            });
    }

    showSMSInterface() {
        // F9 - SMS messaging
        this.speakAction('SMS messaging');
        this.switchToTab('messages');
        this.showToast('F9: SMS Messages', 'info');
    }

    showCallHistory() {
        // Shift+F9 - Show call history
        this.speakAction('Call history');
        this.switchToTab('history');
        this.showToast('Shift+F9: Call History', 'info');
    }

    toggleRingtonePlayback() {
        // F10 - Toggle ringtone playback (silent/audible)
        this.ringtoneEnabled = !this.ringtoneEnabled;

        const status = this.ringtoneEnabled ? 'enabled' : 'disabled';
        this.showToast(`Ringtone ${status}`, 'info');
        this.speakAction(`Ringtone ${status}`);

        // Save setting
        localStorage.setItem('flexphone_ringtone_enabled', this.ringtoneEnabled);

        // Play VoicePack audio
        this.voicePack.playRingtoneToggle(this.ringtoneEnabled);
    }

    toggleDoNotDisturb() {
        // Shift+F10 - Toggle Do Not Disturb mode
        this.doNotDisturbMode = !this.doNotDisturbMode;

        const status = this.doNotDisturbMode ? 'enabled' : 'disabled';
        this.showToast(`Do Not Disturb ${status}`, 'info');
        this.speakAction(`Do Not Disturb mode ${status}`);

        // Save setting
        localStorage.setItem('flexphone_dnd_mode', this.doNotDisturbMode);

        // Play VoicePack audio
        this.voicePack.playDNDToggle(this.doNotDisturbMode);
    }

    // Test tone and auto answer functions

    toggleAutoAnswer() {
        // ` key - Auto answer toggle
        const autoAnswerCheckbox = document.getElementById('autoAnswerEnabled');
        if (autoAnswerCheckbox) {
            autoAnswerCheckbox.checked = !autoAnswerCheckbox.checked;
            this.autoAnswerEnabled = autoAnswerCheckbox.checked;

            const status = this.autoAnswerEnabled ? 'enabled' : 'disabled';
            this.showToast(`Auto Answer ${status}`, 'info');
            this.speakAction(`Auto answer ${status}`);

            // Save setting
            localStorage.setItem('flexphone_auto_answer', this.autoAnswerEnabled);
        } else {
            this.showToast('Auto answer setting not available', 'warning');
            this.speakAction('Auto answer setting not available');
        }
    }

    // Test tones method moved to end of class for better organization

    playWelcomeMessage() {
        // Play FlexPhone welcome message with tones at low volume
        try {
            console.log('ðŸ”Š Starting welcome message sequence...');

            // First ensure AudioContext is ready
            this.ensureAudioContextReady().then(() => {
                // Check if welcome tones are enabled
                const welcomeTonesEnabled = localStorage.getItem('welcomeTonesEnabled');
                if (welcomeTonesEnabled === null || welcomeTonesEnabled === 'true') {
                    // Play welcome tones by default or if enabled
                    this.playWelcomeTones();

                    // Check if screen reader announcements should be made after tones
                    setTimeout(() => {
                        this.handleWelcomeVoiceMessage();
                    }, 2000); // Wait for welcome tones to complete
                } else {
                    // Play voice message immediately if tones are disabled
                    this.handleWelcomeVoiceMessage();
                }
            });

            // Show visual welcome
            this.showToast('Welcome to FlexPhone!', 'success');

        } catch (error) {
            console.error('Failed to play welcome message:', error);
            // Silent fallback - just show visual message
            this.showToast('FlexPhone Ready', 'info');
        }
    }

    async ensureAudioContextReady() {
        if (!this.audioContext) {
            const audioContextOptions = {
                sampleRate: 44100, // Match built-in device default
                latencyHint: 'interactive' // Low latency for real-time audio
            };
            this.audioContext = new (window.AudioContext || window.webkitAudioContext)(audioContextOptions);
            console.log('ðŸ”Š AudioContext created with sample rate:', this.audioContext.sampleRate);
        }

        if (this.audioContext.state === 'suspended') {
            try {
                await this.audioContext.resume();
                console.log('ðŸ”Š AudioContext resumed successfully');
            } catch (error) {
                console.error('Failed to resume AudioContext:', error);
            }
        }
    }

    handleWelcomeVoiceMessage() {
        // Check for screen reader detection setting
        const announceScreenReader = localStorage.getItem('announceScreenReaderOnStartup');
        const isScreenReaderDetected = this.detectScreenReader();

        // Determine if we should announce screen reader status
        let shouldAnnounceScreenReader = false;
        if (announceScreenReader === null || announceScreenReader === 'auto') {
            // Auto mode: announce only if screen reader is detected
            shouldAnnounceScreenReader = isScreenReaderDetected;
        } else if (announceScreenReader === 'always') {
            shouldAnnounceScreenReader = true;
        } else if (announceScreenReader === 'never') {
            shouldAnnounceScreenReader = false;
        }

        // Play voice message based on settings
        if (shouldAnnounceScreenReader) {
            const screenReaderMessage = isScreenReaderDetected
                ? 'FlexPhone ready - Screen reader detected and accessibility features enabled!'
                : 'FlexPhone ready - Welcome!';

            if (this.voicePack && this.voicePack.enabled) {
                this.voicePack.playWelcomeMessage();
            } else {
                this.speakAction(screenReaderMessage, { volume: 0.3, rate: 1.0 });
            }
        }
        // Note: Welcome tones always play regardless of voice message settings
    }

    detectScreenReader() {
        // Check for common screen reader indicators
        const indicators = [
            navigator.userAgent.includes('NVDA'),
            navigator.userAgent.includes('JAWS'),
            navigator.userAgent.includes('VoiceOver'),
            navigator.userAgent.includes('Orca'),
            !!window.speechSynthesis,
            !!navigator.mediaDevices,
            window.navigator.userAgentData?.mobile === false // Desktop more likely to have screen readers
        ];

        // Also check for accessibility API usage
        const hasAccessibilityFeatures = document.querySelector('[aria-label]') ||
                                       document.querySelector('[role]') ||
                                       !!window.SpeechSynthesisUtterance;

        return indicators.some(Boolean) || hasAccessibilityFeatures;
    }

    playWelcomeTones() {
        // Play pleasant welcome tone sequence - ALWAYS plays regardless of VoicePack
        console.log('ðŸŽµ Attempting to play welcome tones...');

        if (!this.audioContext) {
            console.error('âŒ No AudioContext available for welcome tones');
            return;
        }

        if (this.audioContext.state !== 'running') {
            console.warn('âš ï¸ AudioContext not running, state:', this.audioContext.state);
        }

        try {
            // Create ascending welcome tone sequence (C major chord progression)
            const welcomeTones = [
                { frequency: 523, duration: 300 }, // C5
                { frequency: 659, duration: 300 }, // E5
                { frequency: 784, duration: 500 }  // G5 (longer final note)
            ];

            console.log('ðŸŽµ Starting welcome tone sequence with', welcomeTones.length, 'tones');

            let currentTone = 0;
            const playNextWelcomeTone = () => {
                if (currentTone >= welcomeTones.length) {
                    console.log('âœ… Welcome tone sequence completed');
                    return;
                }

                const tone = welcomeTones[currentTone];
                console.log(`ðŸŽµ Playing tone ${currentTone + 1}: ${tone.frequency}Hz for ${tone.duration}ms`);

                // Create oscillator for welcome tone
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();

                oscillator.frequency.setValueAtTime(tone.frequency, this.audioContext.currentTime);
                oscillator.type = 'sine'; // Smooth sine wave for pleasant welcome sound

                // Gentle volume envelope with slightly higher volume for better audibility
                gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                gainNode.gain.linearRampToValueAtTime(0.2, this.audioContext.currentTime + 0.05); // Quick fade in
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + (tone.duration / 1000) - 0.05); // Gentle fade out

                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);

                // Add error handling for oscillator
                oscillator.onerror = (e) => console.error('Oscillator error:', e);
                oscillator.onended = () => console.log(`ðŸŽµ Tone ${currentTone + 1} ended`);

                oscillator.start(this.audioContext.currentTime);
                oscillator.stop(this.audioContext.currentTime + (tone.duration / 1000));

                currentTone++;

                // Schedule next tone with slight overlap for smooth transition
                if (currentTone < welcomeTones.length) {
                    setTimeout(playNextWelcomeTone, tone.duration - 50);
                }
            };

            playNextWelcomeTone();

        } catch (error) {
            console.error('âŒ Failed to play welcome tones:', error);
        }
    }

    // Supporting helper methods

    showDevicePickerDialog(type, devices) {
        // Create device picker dialog
        const dialog = document.createElement('div');
        dialog.className = 'device-picker-dialog';
        dialog.style.cssText = `
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
        `;

        const deviceType = type === 'input' ? 'Input (Microphone)' : 'Output (Speaker)';
        const currentDeviceId = localStorage.getItem(`flexphone_${type}_device`);

        let deviceOptions = '';
        devices.forEach((device, index) => {
            const isSelected = device.deviceId === currentDeviceId;
            const deviceName = device.label || `${deviceType} Device ${index + 1}`;
            deviceOptions += `
                <div class="device-option ${isSelected ? 'selected' : ''}"
                     data-device-id="${device.deviceId}"
                     tabindex="0"
                     role="option"
                     aria-selected="${isSelected}">
                    ${isSelected ? 'âœ“ ' : ''}${deviceName}
                </div>
            `;
        });

        dialog.innerHTML = `
            <div style="
                background: linear-gradient(135deg, #1e1e1e 0%, #2d2d2d 100%);
                border-radius: 8px;
                padding: 24px;
                min-width: 400px;
                max-width: 600px;
                color: white;
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            ">
                <h3 style="margin: 0 0 16px 0; color: #4CAF50;">
                    Select ${deviceType} Device
                </h3>
                <div class="device-list" role="listbox" aria-label="${deviceType} devices">
                    ${deviceOptions}
                </div>
                <div style="margin-top: 20px; text-align: right;">
                    <button class="btn-cancel" style="
                        background: #666;
                        color: white;
                        border: none;
                        padding: 8px 16px;
                        border-radius: 4px;
                        margin-right: 8px;
                        cursor: pointer;
                    ">Cancel</button>
                    <button class="btn-apply" style="
                        background: #4CAF50;
                        color: white;
                        border: none;
                        padding: 8px 16px;
                        border-radius: 4px;
                        cursor: pointer;
                    ">Apply</button>
                </div>
            </div>
        `;

        // Add event listeners
        let selectedDeviceId = currentDeviceId;

        // Clean removal function
        const removeDialog = () => {
            if (document.body.contains(dialog)) {
                document.body.removeChild(dialog);
            }
        };

        // Background click handler
        dialog.addEventListener('click', (e) => {
            if (e.target === dialog) {
                removeDialog();
            }
        });

        // Cancel button handler
        dialog.querySelector('.btn-cancel').addEventListener('click', () => {
            removeDialog();
        });

        // Apply button handler
        dialog.querySelector('.btn-apply').addEventListener('click', () => {
            if (selectedDeviceId) {
                localStorage.setItem(`flexphone_${type}_device`, selectedDeviceId);
                this.showToast(`${deviceType} device updated`, 'success');
                this.speakAction(`${deviceType} device changed`);
            }
            removeDialog();
        });

        // Global keydown handler for dialog to prevent dial tone on Enter
        const dialogKeyHandler = (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                e.stopPropagation();
                // Apply selection if Enter is pressed
                dialog.querySelector('.btn-apply').click();
            } else if (e.key === 'Escape') {
                e.preventDefault();
                e.stopPropagation();
                // Cancel dialog if Escape is pressed
                removeDialog();
            }
        };

        dialog.addEventListener('keydown', dialogKeyHandler);

        // Device selection
        dialog.querySelectorAll('.device-option').forEach(option => {
            option.addEventListener('click', () => {
                dialog.querySelectorAll('.device-option').forEach(opt => {
                    opt.classList.remove('selected');
                    opt.textContent = opt.textContent.replace('âœ“ ', '');
                    opt.setAttribute('aria-selected', 'false');
                });
                option.classList.add('selected');
                option.textContent = 'âœ“ ' + option.textContent;
                option.setAttribute('aria-selected', 'true');
                selectedDeviceId = option.dataset.deviceId;
            });

            option.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    option.click();
                }
            });
        });

        // Add global keydown handler for the dialog
        const dialogKeyHandler = (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                e.stopPropagation();
                // Apply selection if Enter is pressed
                dialog.querySelector('.btn-apply').click();
            } else if (e.key === 'Escape') {
                e.preventDefault();
                e.stopPropagation();
                // Cancel dialog if Escape is pressed
                dialog.querySelector('.btn-cancel').click();
            }
        };

        // Add the event listener to the dialog itself to capture all Enter keys within it
        dialog.addEventListener('keydown', dialogKeyHandler);

        document.body.appendChild(dialog);

        // Focus first device option
        const firstOption = dialog.querySelector('.device-option');
        if (firstOption) {
            firstOption.focus();
        }


        this.speakAction(`${deviceType} device picker opened. ${devices.length} devices available`);
    }

    initializeHoldMusicSystem() {
        // Initialize built-in hold music files (up to 10 files)
        this.holdMusicFiles = [
            { name: 'Classical Hold 1', url: 'assets/sounds/hold-music/classical1.mp3', enabled: true },
            { name: 'Classical Hold 2', url: 'assets/sounds/hold-music/classical2.mp3', enabled: true },
            { name: 'Jazz Hold 1', url: 'assets/sounds/hold-music/jazz1.mp3', enabled: true },
            { name: 'Jazz Hold 2', url: 'assets/sounds/hold-music/jazz2.mp3', enabled: true },
            { name: 'Ambient Hold 1', url: 'assets/sounds/hold-music/ambient1.mp3', enabled: true },
            { name: 'Ambient Hold 2', url: 'assets/sounds/hold-music/ambient2.mp3', enabled: true },
            { name: 'Corporate Hold 1', url: 'assets/sounds/hold-music/corporate1.mp3', enabled: true },
            { name: 'Corporate Hold 2', url: 'assets/sounds/hold-music/corporate2.mp3', enabled: true },
            { name: 'Smooth Hold 1', url: 'assets/sounds/hold-music/smooth1.mp3', enabled: true },
            { name: 'Smooth Hold 2', url: 'assets/sounds/hold-music/smooth2.mp3', enabled: true }
        ];

        // Load hold music preferences
        const savedHoldMusic = localStorage.getItem('flexphone_hold_music_settings');
        if (savedHoldMusic) {
            try {
                const settings = JSON.parse(savedHoldMusic);
                this.holdMusicFiles.forEach((file, index) => {
                    if (settings[index] !== undefined) {
                        file.enabled = settings[index].enabled;
                    }
                });
                this.currentHoldMusicIndex = settings.currentIndex || 0;
            } catch (error) {
                console.log('Using default hold music settings');
            }
        }
    }

    startHoldMusic() {
        // Start hold music for caller (they hear music, we hear silence)
        try {
            // Get enabled hold music files
            const enabledFiles = this.holdMusicFiles.filter(file => file.enabled);

            if (enabledFiles.length === 0) {
                // Fallback to generated tones if no files available
                this.startGeneratedHoldMusic();
                return;
            }

            // Select current hold music file
            const currentFile = enabledFiles[this.currentHoldMusicIndex % enabledFiles.length];

            this.holdMusicAudio = new Audio();
            this.holdMusicAudio.src = currentFile.url;
            this.holdMusicAudio.loop = true;
            this.holdMusicAudio.volume = 0.3; // Moderate volume for hold music

            // Handle file loading
            this.holdMusicAudio.addEventListener('canplaythrough', () => {
                if (this.callOnHoldWithMusic) {
                    this.holdMusicAudio.play().catch(error => {
                        console.log('Hold music autoplay prevented, using generated tones');
                        this.startGeneratedHoldMusic();
                    });
                }
            });

            this.holdMusicAudio.addEventListener('error', () => {
                console.log('Hold music file failed to load, using generated tones');
                this.startGeneratedHoldMusic();
            });

            // Auto-advance to next file when this one ends (if not looping)
            this.holdMusicAudio.addEventListener('ended', () => {
                if (this.callOnHoldWithMusic) {
                    this.currentHoldMusicIndex++;
                    this.startHoldMusic(); // Start next file
                }
            });

            // Start loading
            this.holdMusicAudio.load();

            this.speakAction(`Playing hold music: ${currentFile.name}`);

        } catch (error) {
            console.error('Failed to start hold music:', error);
            this.startGeneratedHoldMusic();
        }
    }

    startGeneratedHoldMusic() {
        // Fallback generated hold music when files are not available
        try {
            this.holdMusicOscillator = this.audioContext.createOscillator();
            this.holdMusicGain = this.audioContext.createGain();

            this.holdMusicOscillator.frequency.setValueAtTime(523, this.audioContext.currentTime); // C5
            this.holdMusicGain.gain.setValueAtTime(0.1, this.audioContext.currentTime);

            this.holdMusicOscillator.connect(this.holdMusicGain);
            this.holdMusicGain.connect(this.audioContext.destination);

            this.holdMusicOscillator.start();

            // Create a pleasant melody pattern
            const melody = [523, 587, 659, 698, 784, 698, 659, 587]; // C-D-E-F-G-F-E-D
            let noteIndex = 0;

            this.holdMusicInterval = setInterval(() => {
                if (this.callOnHoldWithMusic && this.holdMusicOscillator) {
                    this.holdMusicOscillator.frequency.setValueAtTime(
                        melody[noteIndex % melody.length],
                        this.audioContext.currentTime
                    );
                    noteIndex++;
                }
            }, 1000);

            this.speakAction('Playing generated hold music');

        } catch (error) {
            console.error('Failed to start generated hold music:', error);
        }
    }

    stopHoldMusic() {
        // Stop all hold music
        if (this.holdMusicAudio) {
            this.holdMusicAudio.pause();
            this.holdMusicAudio.currentTime = 0;
            this.holdMusicAudio = null;
        }

        if (this.holdMusicOscillator) {
            this.holdMusicOscillator.stop();
            this.holdMusicOscillator = null;
        }

        if (this.holdMusicInterval) {
            clearInterval(this.holdMusicInterval);
            this.holdMusicInterval = null;
        }
    }

    saveHoldMusicSettings() {
        // Save hold music preferences
        const settings = {
            currentIndex: this.currentHoldMusicIndex,
            files: this.holdMusicFiles.map(file => ({ enabled: file.enabled, name: file.name, url: file.url }))
        };
        localStorage.setItem('flexphone_hold_music_settings', JSON.stringify(settings));
    }

    showHoldMusicManager() {
        // Show hold music file manager dialog
        this.speakAction('Hold music manager');

        const dialog = document.createElement('div');
        dialog.className = 'hold-music-manager-dialog';
        dialog.style.cssText = `
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
        `;

        let musicListHTML = '';
        this.holdMusicFiles.forEach((file, index) => {
            const isEnabled = file.enabled ? 'checked' : '';
            const isPlaying = this.holdMusicAudio && !this.holdMusicAudio.paused &&
                             this.currentHoldMusicIndex === index ? 'playing' : '';

            musicListHTML += `
                <div class="music-item ${isPlaying}" data-index="${index}" style="
                    display: flex;
                    align-items: center;
                    padding: 8px;
                    margin: 4px 0;
                    background: ${isPlaying ? '#4CAF50' : '#333'};
                    border-radius: 4px;
                    border: 1px solid #555;
                ">
                    <input type="checkbox" ${isEnabled}
                           onchange="window.flexPhoneApp.toggleHoldMusicFile(${index})"
                           style="margin-right: 8px;">
                    <span style="flex: 1; color: white;">${file.name}</span>
                    <button onclick="window.flexPhoneApp.previewHoldMusic(${index})"
                            style="margin-left: 8px; padding: 4px 8px; background: #4CAF50; color: white; border: none; border-radius: 3px; cursor: pointer;">
                        ${isPlaying ? 'Stop' : 'Preview'}
                    </button>
                    <button onclick="window.flexPhoneApp.removeHoldMusicFile(${index})"
                            style="margin-left: 4px; padding: 4px 8px; background: #f44336; color: white; border: none; border-radius: 3px; cursor: pointer;">
                        Remove
                    </button>
                </div>
            `;
        });

        dialog.innerHTML = `
            <div style="
                background: linear-gradient(135deg, #1e1e1e 0%, #2d2d2d 100%);
                border-radius: 8px;
                padding: 24px;
                min-width: 500px;
                max-width: 700px;
                max-height: 80vh;
                overflow-y: auto;
                color: white;
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            ">
                <h3 style="margin: 0 0 16px 0; color: #4CAF50;">
                    ðŸŽµ Hold Music Manager
                </h3>

                <div style="margin-bottom: 16px;">
                    <input type="file" id="holdMusicFileInput" accept=".mp3,.wav,.ogg,.m4a"
                           multiple style="display: none;"
                           onchange="window.flexPhoneApp.importHoldMusicFiles(this.files)">
                    <button onclick="document.getElementById('holdMusicFileInput').click()"
                            style="
                                background: #4CAF50;
                                color: white;
                                border: none;
                                padding: 10px 16px;
                                border-radius: 4px;
                                cursor: pointer;
                                margin-right: 8px;
                            ">
                        Import Audio Files
                    </button>
                    <button onclick="window.flexPhoneApp.resetHoldMusicToDefaults()"
                            style="
                                background: #ff9800;
                                color: white;
                                border: none;
                                padding: 10px 16px;
                                border-radius: 4px;
                                cursor: pointer;
                            ">
                        Reset to Defaults
                    </button>
                </div>

                <div class="music-list" style="max-height: 300px; overflow-y: auto;">
                    ${musicListHTML}
                </div>

                <div style="margin-top: 20px; text-align: right;">
                    <button class="btn-close" style="
                        background: #666;
                        color: white;
                        border: none;
                        padding: 10px 20px;
                        border-radius: 4px;
                        cursor: pointer;
                    ">Close</button>
                </div>
            </div>
        `;

        // Add event listeners
        dialog.addEventListener('click', (e) => {
            if (e.target === dialog) {
                document.body.removeChild(dialog);
            }
        });

        dialog.querySelector('.btn-close').addEventListener('click', () => {
            document.body.removeChild(dialog);
        });

        document.body.appendChild(dialog);

        this.speakAction(`Hold music manager opened. ${this.holdMusicFiles.length} music files available`);
    }

    toggleHoldMusicFile(index) {
        if (index >= 0 && index < this.holdMusicFiles.length) {
            this.holdMusicFiles[index].enabled = !this.holdMusicFiles[index].enabled;
            this.saveHoldMusicSettings();

            const status = this.holdMusicFiles[index].enabled ? 'enabled' : 'disabled';
            this.speakAction(`${this.holdMusicFiles[index].name} ${status}`);
        }
    }

    previewHoldMusic(index) {
        // Preview hold music file
        if (this.holdMusicAudio && !this.holdMusicAudio.paused) {
            // Stop current preview
            this.holdMusicAudio.pause();
            this.holdMusicAudio.currentTime = 0;
            this.speakAction('Music preview stopped');
            return;
        }

        if (index >= 0 && index < this.holdMusicFiles.length) {
            const file = this.holdMusicFiles[index];

            this.holdMusicAudio = new Audio();
            this.holdMusicAudio.src = file.url;
            this.holdMusicAudio.volume = 0.5;

            this.holdMusicAudio.addEventListener('canplaythrough', () => {
                this.holdMusicAudio.play().catch(error => {
                    this.speakAction('Cannot preview this audio file');
                });
            });

            this.holdMusicAudio.addEventListener('error', () => {
                this.speakAction('Audio file failed to load');
            });

            this.holdMusicAudio.load();
            this.speakAction(`Previewing ${file.name}`);
        }
    }

    async importHoldMusicFiles(files) {
        // Import custom hold music files
        if (!files || files.length === 0) return;

        this.speakAction(`Importing ${files.length} audio files`);

        for (let i = 0; i < files.length && this.holdMusicFiles.length < 20; i++) { // Limit to 20 total files
            const file = files[i];

            // Validate file type
            if (!file.type.startsWith('audio/')) {
                this.showToast(`Skipped ${file.name} - not an audio file`, 'warning');
                continue;
            }

            // Create object URL for the file
            const fileURL = URL.createObjectURL(file);

            // Add to hold music files
            const musicFile = {
                name: file.name.replace(/\.[^/.]+$/, ""), // Remove extension
                url: fileURL,
                enabled: true,
                custom: true
            };

            this.holdMusicFiles.push(musicFile);
        }

        this.saveHoldMusicSettings();
        this.showToast(`Imported ${Math.min(files.length, 20 - this.holdMusicFiles.length)} audio files`, 'success');
        this.speakAction(`Import complete. ${this.holdMusicFiles.length} total music files available`);

        // Refresh the dialog if it's open
        const existingDialog = document.querySelector('.hold-music-manager-dialog');
        if (existingDialog) {
            document.body.removeChild(existingDialog);
            this.showHoldMusicManager();
        }
    }

    removeHoldMusicFile(index) {
        if (index >= 0 && index < this.holdMusicFiles.length) {
            const file = this.holdMusicFiles[index];

            // Don't allow removal of built-in files unless user confirms
            if (!file.custom) {
                const confirmed = confirm(`Remove built-in music file "${file.name}"? You can restore it by resetting to defaults.`);
                if (!confirmed) return;
            }

            // Clean up object URL if it's a custom file
            if (file.custom && file.url.startsWith('blob:')) {
                URL.revokeObjectURL(file.url);
            }

            this.holdMusicFiles.splice(index, 1);
            this.saveHoldMusicSettings();

            this.speakAction(`${file.name} removed`);
            this.showToast(`Removed ${file.name}`, 'info');

            // Refresh the dialog
            const existingDialog = document.querySelector('.hold-music-manager-dialog');
            if (existingDialog) {
                document.body.removeChild(existingDialog);
                this.showHoldMusicManager();
            }
        }
    }

    resetHoldMusicToDefaults() {
        // Reset to default hold music files
        const confirmed = confirm('Reset all hold music to default files? This will remove any imported custom files.');
        if (!confirmed) return;

        // Clean up custom file URLs
        this.holdMusicFiles.forEach(file => {
            if (file.custom && file.url.startsWith('blob:')) {
                URL.revokeObjectURL(file.url);
            }
        });

        // Reset to defaults
        this.initializeHoldMusicSystem();
        this.saveHoldMusicSettings();

        this.speakAction('Hold music reset to defaults');
        this.showToast('Hold music reset to defaults', 'info');

        // Refresh the dialog
        const existingDialog = document.querySelector('.hold-music-manager-dialog');
        if (existingDialog) {
            document.body.removeChild(existingDialog);
            this.showHoldMusicManager();
        }
    }

    showTransferDialog() {
        // Create enhanced transfer dialog with blind and attended options
        this.speakAction('Call transfer options');

        const dialog = document.createElement('div');
        dialog.className = 'transfer-dialog';
        dialog.style.cssText = `
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
        `;

        dialog.innerHTML = `
            <div style="
                background: linear-gradient(135deg, #1e1e1e 0%, #2d2d2d 100%);
                border-radius: 8px;
                padding: 24px;
                min-width: 400px;
                max-width: 500px;
                color: white;
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            ">
                <h3 style="margin: 0 0 16px 0; color: #4CAF50;">
                    ðŸ“ž Call Transfer
                </h3>

                <div style="margin-bottom: 16px;">
                    <label style="display: block; margin-bottom: 8px;">Transfer to:</label>
                    <input type="text" id="transferNumber" placeholder="Extension or phone number"
                           style="
                               width: 100%;
                               padding: 8px;
                               border: 1px solid #555;
                               border-radius: 4px;
                               background: #333;
                               color: white;
                               font-size: 14px;
                           ">
                </div>

                <div style="margin-bottom: 20px;">
                    <p style="margin: 8px 0; font-size: 14px; color: #ccc;">
                        Choose transfer type:
                    </p>
                    <div style="margin: 8px 0;">
                        <label style="display: flex; align-items: center; margin-bottom: 8px;">
                            <input type="radio" name="transferType" value="blind" checked
                                   style="margin-right: 8px;">
                            <span>Blind Transfer</span>
                            <small style="color: #999; margin-left: 8px;">(Transfer immediately)</small>
                        </label>
                        <label style="display: flex; align-items: center;">
                            <input type="radio" name="transferType" value="attended"
                                   style="margin-right: 8px;">
                            <span>Attended Transfer</span>
                            <small style="color: #999; margin-left: 8px;">(Talk first, then transfer)</small>
                        </label>
                    </div>
                </div>

                <div style="text-align: right;">
                    <button class="btn-cancel" style="
                        background: #666;
                        color: white;
                        border: none;
                        padding: 10px 16px;
                        border-radius: 4px;
                        margin-right: 8px;
                        cursor: pointer;
                    ">Cancel</button>
                    <button class="btn-transfer" style="
                        background: #4CAF50;
                        color: white;
                        border: none;
                        padding: 10px 16px;
                        border-radius: 4px;
                        cursor: pointer;
                    ">Transfer Call</button>
                </div>
            </div>
        `;

        // Add event listeners
        dialog.addEventListener('click', (e) => {
            if (e.target === dialog) {
                document.body.removeChild(dialog);
            }
        });

        dialog.querySelector('.btn-cancel').addEventListener('click', () => {
            document.body.removeChild(dialog);
        });

        dialog.querySelector('.btn-transfer').addEventListener('click', () => {
            const transferNumber = dialog.querySelector('#transferNumber').value.trim();
            const transferType = dialog.querySelector('input[name="transferType"]:checked').value;

            if (!transferNumber) {
                this.speakAction('Please enter a number to transfer to');
                return;
            }

            document.body.removeChild(dialog);

            if (transferType === 'blind') {
                this.performBlindTransfer(transferNumber);
            } else {
                this.performAttendedTransfer(transferNumber);
            }
        });

        // Handle Enter key in number input
        dialog.querySelector('#transferNumber').addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                dialog.querySelector('.btn-transfer').click();
            }
        });

        document.body.appendChild(dialog);

        // Focus the number input
        setTimeout(() => {
            dialog.querySelector('#transferNumber').focus();
        }, 100);

        this.speakAction('Transfer dialog opened. Choose blind or attended transfer');
    }

    showConferenceDialog() {
        // Create conference call dialog
        const conferenceNumber = prompt('Enter number or extension to add to conference:');
        if (conferenceNumber && conferenceNumber.trim()) {
            this.addToConference(conferenceNumber.trim());
        }
    }

    async performBlindTransfer(targetNumber) {
        try {
            this.showToast(`Blind transfer to ${targetNumber}...`, 'info');
            this.speakAction(`Performing blind transfer to ${targetNumber}`);

            // TODO: Implement actual SIP blind transfer
            // Blind transfer immediately connects the caller to the target without consultation
            await new Promise(resolve => setTimeout(resolve, 1500));

            // Hang up our side of the call since it's transferred
            this.currentCall = null;
            this.showToast('Blind transfer completed', 'success');
            this.speakAction('Blind transfer completed - call handed off');

            // Play VoicePack transfer sound
            this.voicePack.playTransferSound();

        } catch (error) {
            this.showToast('Blind transfer failed', 'error');
            this.speakAction('Blind transfer failed');
        }
    }

    async performAttendedTransfer(targetNumber) {
        try {
            this.showToast(`Calling ${targetNumber} for attended transfer...`, 'info');
            this.speakAction(`Calling ${targetNumber} for consultation`);

            // TODO: Implement actual SIP attended transfer
            // Attended transfer allows talking to the target before completing transfer
            await new Promise(resolve => setTimeout(resolve, 2000));

            // Simulate consultation call establishment
            this.showToast('Consultation call connected', 'info');
            this.speakAction('Consultation call established. Press F4 to complete transfer or F2 to cancel');

            // Set up attended transfer state
            this.attendedTransferTarget = targetNumber;
            this.inAttendedTransfer = true;

            // For simulation, auto-complete after 3 seconds
            setTimeout(() => {
                if (this.inAttendedTransfer) {
                    this.completeAttendedTransfer();
                }
            }, 3000);

        } catch (error) {
            this.showToast('Attended transfer setup failed', 'error');
            this.speakAction('Attended transfer setup failed');
        }
    }

    async completeAttendedTransfer() {
        if (!this.inAttendedTransfer || !this.attendedTransferTarget) return;

        try {
            this.showToast('Completing attended transfer...', 'info');
            this.speakAction('Completing attended transfer');

            // TODO: Implement actual SIP attended transfer completion
            await new Promise(resolve => setTimeout(resolve, 1000));

            this.showToast('Attended transfer completed', 'success');
            this.speakAction('Attended transfer completed successfully');

            // Clean up transfer state
            this.inAttendedTransfer = false;
            this.attendedTransferTarget = null;
            this.currentCall = null;

            // Play VoicePack transfer sound
            this.voicePack.playTransferSound();

        } catch (error) {
            this.showToast('Transfer completion failed', 'error');
            this.speakAction('Transfer completion failed');
        }
    }

    cancelAttendedTransfer() {
        if (!this.inAttendedTransfer) return;

        this.showToast('Attended transfer cancelled', 'info');
        this.speakAction('Attended transfer cancelled - returning to original call');

        // Clean up transfer state
        this.inAttendedTransfer = false;
        this.attendedTransferTarget = null;
    }

    async addToConference(targetNumber) {
        try {
            this.showToast(`Adding ${targetNumber} to conference...`, 'info');
            this.speakAction(`Adding ${targetNumber} to conference`);

            // TODO: Implement actual SIP conference
            // For now, simulate the conference addition
            await new Promise(resolve => setTimeout(resolve, 2000));

            this.isInConference = true;
            this.showToast('Conference call established', 'success');
            this.speakAction('Conference call active');

        } catch (error) {
            this.showToast('Conference setup failed', 'error');
            this.speakAction('Conference setup failed');
        }
    }

    async leaveConferenceQuietly() {
        try {
            // TODO: Implement actual quiet conference exit
            // For now, simulate leaving
            await new Promise(resolve => setTimeout(resolve, 1000));

            this.isInConference = false;
            this.currentCall = null;

        } catch (error) {
            throw new Error('Failed to leave conference');
        }
    }

    adjustOutputVolume(delta) {
        this.outputVolume = Math.max(0, Math.min(1, this.outputVolume + delta));
        this.showToast(`Output Volume: ${Math.round(this.outputVolume * 100)}%`, 'info');

        // Update any active audio with new volume
        if (this.dialToneOscillator) {
            this.dialToneOscillator.gainNode.gain.setValueAtTime(
                this.outputVolume * 0.5,
                this.audioContext.currentTime
            );
        }
    }

    adjustInputVolume(delta) {
        this.inputVolume = Math.max(0, Math.min(1, this.inputVolume + delta));
        this.showToast(`Input Volume: ${Math.round(this.inputVolume * 100)}%`, 'info');

        // TODO: Apply input volume to microphone gain
        // This would typically be applied to the microphone stream
    }

    openSettingsWindow() {
        // For now, switch to settings tab (will be replaced with separate window)
        this.switchTab('settings');
        this.showToast('Settings opened (Cmd+,)', 'info');
    }

    handleEscapeKey() {
        // Clear any escape timer
        if (this.escapeTimer) {
            clearTimeout(this.escapeTimer);
        }

        // Increment escape count
        this.escapeCount++;

        if (this.escapeCount === 1) {
            // First escape - clear display (normal behavior)
            this.clearDisplay();
            this.showToast('Escape 1/3', 'info');
        } else if (this.escapeCount === 2) {
            // Second escape
            this.showToast('Escape 2/3 - Press once more to minimize', 'warning');
        } else if (this.escapeCount >= 3) {
            // Third escape - minimize to system tray
            this.minimizeToTray();
            this.escapeCount = 0; // Reset
            return;
        }

        // Reset escape count after 2 seconds if no more escapes
        this.escapeTimer = setTimeout(() => {
            this.escapeCount = 0;
        }, 2000);
    }

    minimizeToTray() {
        this.showToast('Minimizing to system tray...', 'info');

        // Use Electron API to minimize to tray
        if (window.flexPhoneAPI && window.flexPhoneAPI.window) {
            window.flexPhoneAPI.window.minimizeToTray();
        } else {
            // Fallback: hide the window
            window.minimize();
        }
    }

    async hangupCall() {
        if (!this.currentCall) return;

        try {
            // Track call ended with PBX before hanging up
            this.trackCallEnded({
                id: this.currentCall.id,
                number: this.currentNumber,
                endReason: 'user_hangup'
            });

            await window.flexPhoneAPI.sip.hangupCall(this.currentCall);
            this.currentCall = null;
            this.callBtn.style.display = 'inline-block';
            this.hangupBtn.style.display = 'none';
        } catch (error) {
            this.showToast(`Hangup error: ${error.message}`, 'error');
        }
    }

    async answerCall() {
        if (!this.currentCall) return;

        try {
            // Stop caller ID ringtone
            this.stopCallerIDRingtone();

            await window.flexPhoneAPI.sip.answerCall(this.currentCall);
            this.hideIncomingCallOverlay();
            this.callBtn.style.display = 'none';
            this.hangupBtn.style.display = 'inline-block';
        } catch (error) {
            this.showToast(`Answer error: ${error.message}`, 'error');
        }
    }

    async declineCall() {
        if (!this.currentCall) return;

        try {
            // Stop caller ID ringtone
            this.stopCallerIDRingtone();

            await window.flexPhoneAPI.sip.hangupCall(this.currentCall);
            this.hideIncomingCallOverlay();
            this.currentCall = null;
        } catch (error) {
            this.showToast(`Decline error: ${error.message}`, 'error');
        }
    }

    async connectSIP() {
        const config = {
            provider: this.sipProvider.value,
            server: this.sipServer.value,
            port: parseInt(this.sipPort.value),
            username: this.sipUsername.value,
            password: this.sipPassword.value,
            displayName: this.sipDisplayName.value
        };

        try {
            const result = await window.flexPhoneAPI.sip.connect(config);
            if (result.success) {
                this.isConnected = true;
                this.updateConnectionStatus(true, result.config.provider);
                this.connectBtn.style.display = 'none';
                this.disconnectBtn.style.display = 'inline-block';
                this.showToast('Connected to SIP server', 'success');
            } else {
                this.showToast(`Connection failed: ${result.error}`, 'error');
            }
        } catch (error) {
            this.showToast(`Connection error: ${error.message}`, 'error');
        }
    }

    async disconnectSIP() {
        try {
            await window.flexPhoneAPI.sip.disconnect();
            this.isConnected = false;
            this.updateConnectionStatus(false);
            this.connectBtn.style.display = 'inline-block';
            this.disconnectBtn.style.display = 'none';
            this.showToast('Disconnected from SIP server', 'info');
        } catch (error) {
            this.showToast(`Disconnect error: ${error.message}`, 'error');
        }
    }

    updateConnectionStatus(connected, provider = null) {
        this.isConnected = connected;

        if (connected) {
            this.statusIndicator.classList.add('connected');
            this.connectionStatus.textContent = `Connected to ${provider}`;
        } else {
            this.statusIndicator.classList.remove('connected');
            this.connectionStatus.textContent = 'Disconnected';
        }
    }

    onSIPConnected(data) {
        this.isConnected = true;
        this.updateConnectionStatus(true, data.provider);
        this.showToast('SIP connected', 'success');
    }

    onSIPDisconnected(data) {
        this.isConnected = false;
        this.updateConnectionStatus(false);
        this.showToast('SIP disconnected', 'info');
    }

    onIncomingCall(call) {
        this.handleIncomingCall(call);
    }

    onCallAnswered(call) {
        this.currentCall = call.id;
        this.callBtn.style.display = 'none';
        this.hangupBtn.style.display = 'inline-block';
        this.showToast('Call connected', 'success');
    }

    onCallEnded(call) {
        this.currentCall = null;
        this.callBtn.style.display = 'inline-block';
        this.hangupBtn.style.display = 'none';
        this.hideIncomingCallOverlay();
        this.showToast('Call ended', 'info');
    }

    onSMSReceived(message) {
        this.showToast(`New message from ${message.from}`, 'info');
        // Update messages tab if needed
    }

    showIncomingCallOverlay(call) {
        this.callerName.textContent = call.remoteName || 'Unknown Caller';
        this.callerNumber.textContent = call.remoteNumber;
        this.incomingCallOverlay.classList.add('show');
    }

    hideIncomingCallOverlay() {
        this.incomingCallOverlay.classList.remove('show');
    }

    switchTab(tabName) {
        // Update navigation
        this.navTabs.forEach(tab => {
            if (tab.dataset.tab === tabName) {
                tab.classList.add('active');
            } else {
                tab.classList.remove('active');
            }
        });

        // Update content
        this.tabContents.forEach(content => {
            if (content.id === tabName) {
                content.classList.add('active');
            } else {
                content.classList.remove('active');
            }
        });

        this.activeTab = tabName;

        // Load tab content if needed
        this.loadTabContent(tabName);
    }

    setupSelectKeyboardNavigation(selectElement) {
        selectElement.addEventListener('keydown', (e) => {
            // Ensure the select is focusable and has options
            if (!selectElement.options || selectElement.options.length === 0) {
                return;
            }

            switch (e.key) {
                case 'ArrowDown':
                    e.preventDefault();
                    if (selectElement.selectedIndex < selectElement.options.length - 1) {
                        selectElement.selectedIndex++;
                        this.triggerSelectChange(selectElement);
                    } else {
                        // At bottom - announce last option and boundary
                        this.announceSelectBoundary(selectElement, 'bottom');
                    }
                    break;

                case 'ArrowUp':
                    e.preventDefault();
                    if (selectElement.selectedIndex > 0) {
                        selectElement.selectedIndex--;
                        this.triggerSelectChange(selectElement);
                    } else {
                        // At top - announce boundary only
                        this.announceSelectBoundary(selectElement, 'top');
                    }
                    break;

                case 'Home':
                    e.preventDefault();
                    if (selectElement.selectedIndex !== 0) {
                        selectElement.selectedIndex = 0;
                        this.triggerSelectChange(selectElement);
                    } else {
                        this.announceSelectBoundary(selectElement, 'top');
                    }
                    break;

                case 'End':
                    e.preventDefault();
                    const lastIndex = selectElement.options.length - 1;
                    if (selectElement.selectedIndex !== lastIndex) {
                        selectElement.selectedIndex = lastIndex;
                        this.triggerSelectChange(selectElement);
                    } else {
                        this.announceSelectBoundary(selectElement, 'bottom');
                    }
                    break;

                case 'Enter':
                case ' ':
                    // Let the browser handle opening the dropdown
                    break;

                default:
                    // Handle alphanumeric quick selection
                    if (e.key.length === 1 && /[a-zA-Z0-9]/.test(e.key)) {
                        this.handleQuickSelectSearch(selectElement, e.key.toLowerCase());
                        e.preventDefault();
                    }
                    break;
            }
        });

        // Add focus/blur handling for better accessibility
        selectElement.addEventListener('focus', () => {
            selectElement.setAttribute('aria-expanded', 'false');
        });

        selectElement.addEventListener('blur', () => {
            selectElement.removeAttribute('aria-expanded');
        });
    }

    triggerSelectChange(selectElement) {
        // Trigger change event programmatically
        const changeEvent = new Event('change', { bubbles: true });
        selectElement.dispatchEvent(changeEvent);

        // Announce just the selected option text for screen readers
        if (window.accessibilityManager) {
            const selectedOption = selectElement.options[selectElement.selectedIndex];
            window.accessibilityManager.announceStatus('', selectedOption.text);
        }
    }

    announceSelectBoundary(selectElement, boundary) {
        if (window.accessibilityManager) {
            if (boundary === 'top') {
                window.accessibilityManager.announceStatus('', 'Already at top');
            } else if (boundary === 'bottom') {
                const lastOption = selectElement.options[selectElement.options.length - 1];
                window.accessibilityManager.announceStatus('', `${lastOption.text}, already at bottom`);
            }
        }
    }

    handleQuickSelectSearch(selectElement, char) {
        // Find the first option that starts with the typed character
        for (let i = 0; i < selectElement.options.length; i++) {
            const option = selectElement.options[i];
            if (option.text.toLowerCase().startsWith(char)) {
                selectElement.selectedIndex = i;
                this.triggerSelectChange(selectElement);
                break;
            }
        }
    }

    async loadTabContent(tabName) {
        const content = document.getElementById(tabName);

        switch (tabName) {
            case 'contacts':
                await this.loadContacts(content);
                break;
            case 'history':
                await this.loadCallHistory(content);
                break;
            case 'messages':
                await this.loadMessages(content);
                break;
            case 'sip-clients':
                await this.loadSipClients();
                break;
            case 'settings':
                await this.loadSettings();
                break;
        }
    }

    async loadContacts(container) {
        try {
            const contacts = await window.flexPhoneAPI.contacts.getAll();

            if (contacts.length === 0) {
                container.innerHTML = '<div class="empty-state">ðŸ“± No contacts yet<br><small>Add contacts to get started</small></div>';
                return;
            }

            const list = document.createElement('ul');
            list.className = 'list';

            contacts.forEach(contact => {
                const item = document.createElement('li');
                item.className = 'list-item';
                item.innerHTML = `
                    <div class="list-item-icon">ðŸ‘¤</div>
                    <div class="list-item-content">
                        <div class="list-item-title">${contact.displayName}</div>
                        <div class="list-item-subtitle">${contact.phoneNumbers[0]?.number || 'No phone'}</div>
                    </div>
                    <div class="list-item-meta">ðŸ“ž</div>
                `;

                item.addEventListener('click', () => {
                    if (contact.phoneNumbers[0]) {
                        this.currentNumber = contact.phoneNumbers[0].number;
                        this.switchTab('dialer');
                        this.updateDisplay();
                    }
                });

                list.appendChild(item);
            });

            container.innerHTML = '';
            container.appendChild(list);

        } catch (error) {
            container.innerHTML = '<div class="empty-state">âŒ Failed to load contacts</div>';
        }
    }

    async loadCallHistory(container) {
        try {
            const history = await window.flexPhoneAPI.history.getCalls(50);

            if (history.length === 0) {
                container.innerHTML = '<div class="empty-state">ðŸ“ž No call history<br><small>Make or receive calls to see history</small></div>';
                return;
            }

            const list = document.createElement('ul');
            list.className = 'list';

            history.forEach(call => {
                const item = document.createElement('li');
                item.className = 'list-item';

                const icon = call.direction === 'inbound' ?
                    (call.status === 'missed' ? 'ðŸ“žâŒ' : 'ðŸ“žâ¬‡ï¸') : 'ðŸ“žâ¬†ï¸';

                const time = new Date(call.startTime).toLocaleString();

                item.innerHTML = `
                    <div class="list-item-icon">${icon}</div>
                    <div class="list-item-content">
                        <div class="list-item-title">${call.remoteName || call.remoteNumber}</div>
                        <div class="list-item-subtitle">${call.status} â€¢ ${this.formatDuration(call.duration)}</div>
                    </div>
                    <div class="list-item-meta">${time}</div>
                `;

                item.addEventListener('click', () => {
                    this.currentNumber = call.remoteNumber;
                    this.switchTab('dialer');
                    this.updateDisplay();
                });

                list.appendChild(item);
            });

            container.innerHTML = '';
            container.appendChild(list);

        } catch (error) {
            container.innerHTML = '<div class="empty-state">âŒ Failed to load call history</div>';
        }
    }

    async loadMessages(container) {
        try {
            const conversations = await window.flexPhoneAPI.sms.getConversations();

            if (conversations.length === 0) {
                container.innerHTML = '<div class="empty-state">ðŸ’¬ No messages yet<br><small>Send SMS messages to get started</small></div>';
                return;
            }

            const list = document.createElement('ul');
            list.className = 'list';

            conversations.forEach(conv => {
                const item = document.createElement('li');
                item.className = 'list-item';

                const time = new Date(conv.lastMessageTime).toLocaleString();

                item.innerHTML = `
                    <div class="list-item-icon">ðŸ’¬</div>
                    <div class="list-item-content">
                        <div class="list-item-title">${conv.displayName}</div>
                        <div class="list-item-subtitle">${conv.lastMessage}</div>
                    </div>
                    <div class="list-item-meta">${time}</div>
                `;

                list.appendChild(item);
            });

            container.innerHTML = '';
            container.appendChild(list);

        } catch (error) {
            container.innerHTML = '<div class="empty-state">âŒ Failed to load messages</div>';
        }
    }

    async loadSettings() {
        try {
            const settings = await window.flexPhoneAPI.settings.getAll();

            this.sipProvider.value = settings['sip.provider'] || 'FLEXPBX';
            this.sipServer.value = settings['sip.server'] || 'flexpbx.local';
            this.sipPort.value = settings['sip.port'] || 5070;
            this.sipUsername.value = settings['sip.username'] || '';
            this.sipPassword.value = settings['sip.password'] || '';
            this.sipDisplayName.value = settings['sip.displayName'] || '';

            // Load advanced settings
            this.autoAnswerEnabled.checked = settings['sip.autoAnswer'] || false;
            this.autoAnswerDelay.value = settings['sip.autoAnswerDelay'] || 3;
            this.handsFreeMode.checked = settings['sip.handsFree'] || false;
            this.intercomEnabled.checked = settings['sip.intercom'] || false;
            this.flexPhoneIntegration.checked = settings['sip.flexPhoneIntegration'] || false;

        } catch (error) {
            console.error('Failed to load settings:', error);
        }
    }

    handleProviderChange() {
        const provider = this.sipProvider.value;

        // Show configuration help based on selected provider (no auto-fill)
        switch(provider) {
            case 'FLEXPBX':
                this.showProviderHelp('FlexPBX', 'Server: flexpbx.local\nPort: 5070');
                break;

            case 'CALLCENTRIC':
                this.showProviderHelp('CallCentric', 'Server: callcentric.com\nPort: 5060');
                break;

            case 'VOIPMS':
                this.showProviderHelp('VoIP.ms', 'Server: chicago.voip.ms (or your regional server)\nPort: 5060');
                break;

            case 'TWILIO':
                this.showProviderHelp('Twilio', 'Server: yourdomain.sip.twilio.com\nPort: 5060');
                break;

            case 'GOOGLE_VOICE':
                this.showGoogleVoiceHelp();
                break;

            case 'CUSTOM':
                this.showProviderHelp('Custom Provider', 'Enter your SIP provider details manually');
                break;
        }
    }

    showProviderHelp(provider, helpText) {
        const statusDisplay = document.getElementById('statusDisplay');
        if (statusDisplay) {
            const originalContent = statusDisplay.textContent;
            statusDisplay.textContent = `${provider} Configuration:\n${helpText}\n\n(Auto-selecting in 10 seconds...)`;
            statusDisplay.style.fontSize = '11px';
            statusDisplay.style.textAlign = 'left';
            statusDisplay.style.whiteSpace = 'pre-wrap';

            // After 10 seconds, confirm selection and move to server field
            setTimeout(() => {
                // Move focus to server input field
                const serverInput = document.getElementById('sipServer');
                if (serverInput) {
                    serverInput.focus();
                    serverInput.select();
                }
                statusDisplay.textContent = `${provider} selected. Enter your server details.`;
            }, 10000);

            // Restore original content after 30 seconds total
            setTimeout(() => {
                statusDisplay.textContent = originalContent;
                statusDisplay.style.fontSize = '';
                statusDisplay.style.textAlign = '';
                statusDisplay.style.whiteSpace = '';
            }, 30000);
        }
    }

    showGoogleVoiceHelp() {
        // Display Google Voice configuration help
        const helpText = `
Google Voice Configuration:
1. Server: obihai.com (or gvgw.obihai.com)
2. Username: Your 11-digit Google Voice number
3. Password: Google account password or app-specific password
4. Domain: obihai.com

Alternative: Use sip.google.com if OBiHAI doesn't work.
Visit: https://www.obitalk.com/info/googlevoice for setup guide.

(Auto-selecting in 10 seconds...)
        `;

        // Show in status display temporarily
        const statusDisplay = document.getElementById('statusDisplay');
        if (statusDisplay) {
            const originalContent = statusDisplay.textContent;
            statusDisplay.textContent = helpText;
            statusDisplay.style.fontSize = '11px';
            statusDisplay.style.textAlign = 'left';
            statusDisplay.style.whiteSpace = 'pre-wrap';

            // After 10 seconds, confirm selection and move to server field
            setTimeout(() => {
                // Move focus to server input field
                const serverInput = document.getElementById('sipServer');
                if (serverInput) {
                    serverInput.focus();
                    serverInput.select();
                }
                statusDisplay.textContent = 'Google Voice selected. Enter obihai.com for server.';
            }, 10000);

            // Restore original content after 30 seconds total
            setTimeout(() => {
                statusDisplay.textContent = originalContent;
                statusDisplay.style.fontSize = '';
                statusDisplay.style.textAlign = '';
                statusDisplay.style.whiteSpace = '';
            }, 30000);
        }
    }

    async saveSettings() {
        try {
            await window.flexPhoneAPI.settings.set('sip.provider', this.sipProvider.value);
            await window.flexPhoneAPI.settings.set('sip.server', this.sipServer.value);
            await window.flexPhoneAPI.settings.set('sip.port', parseInt(this.sipPort.value));
            await window.flexPhoneAPI.settings.set('sip.username', this.sipUsername.value);
            await window.flexPhoneAPI.settings.set('sip.password', this.sipPassword.value);
            await window.flexPhoneAPI.settings.set('sip.displayName', this.sipDisplayName.value);

        } catch (error) {
            console.error('Failed to save settings:', error);
        }
    }

    formatDuration(duration) {
        if (!duration) return '0s';

        const seconds = Math.floor(duration / 1000);
        const minutes = Math.floor(seconds / 60);
        const remainingSeconds = seconds % 60;

        if (minutes > 0) {
            return `${minutes}m ${remainingSeconds}s`;
        } else {
            return `${remainingSeconds}s`;
        }
    }

    showToast(message, type = 'info') {
        // Simple toast notification
        const toast = document.createElement('div');
        toast.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: ${type === 'error' ? '#dc3545' : type === 'success' ? '#28a745' : type === 'warning' ? '#ffc107' : '#007bff'};
            color: white;
            padding: 12px 20px;
            border-radius: 6px;
            z-index: 1001;
            font-size: 14px;
            opacity: 0;
            transform: translateX(100%);
            transition: all 0.3s ease;
        `;
        toast.textContent = message;

        document.body.appendChild(toast);

        // Animate in
        setTimeout(() => {
            toast.style.opacity = '1';
            toast.style.transform = 'translateX(0)';
        }, 100);

        // Remove after 3 seconds
        setTimeout(() => {
            toast.style.opacity = '0';
            toast.style.transform = 'translateX(100%)';
            setTimeout(() => {
                document.body.removeChild(toast);
            }, 300);
        }, 3000);
    }

    // Auto-complete functionality
    async loadContacts() {
        try {
            this.contacts = await window.flexPhoneAPI.contacts.getAll();
            console.log(`ðŸ“± Loaded ${this.contacts.length} contacts`);
        } catch (error) {
            console.error('âŒ Failed to load contacts:', error);
            this.contacts = [];
        }
    }

    updateAutoComplete() {
        const query = this.currentNumber.toLowerCase();
        if (query.length < 1) {
            this.hideAutoComplete();
            return;
        }

        // Filter contacts by name or number
        this.autoCompleteItems = this.contacts.filter(contact => {
            return contact.name.toLowerCase().includes(query) ||
                   contact.numbers.some(num => num.includes(query));
        }).slice(0, 5); // Limit to 5 results

        if (this.autoCompleteItems.length > 0) {
            this.showAutoComplete();
        } else {
            this.hideAutoComplete();
        }
    }

    showAutoComplete() {
        this.autoCompleteDropdown.innerHTML = '';
        this.selectedAutoCompleteIndex = -1;

        this.autoCompleteItems.forEach((contact, index) => {
            const item = document.createElement('div');
            item.className = 'auto-complete-item';
            item.innerHTML = `
                <span class="auto-complete-name">${contact.name}</span>
                <span class="auto-complete-number">${contact.numbers[0]}</span>
            `;

            item.addEventListener('click', () => {
                this.selectAutoCompleteItem(index);
            });

            this.autoCompleteDropdown.appendChild(item);
        });

        this.autoCompleteDropdown.style.display = 'block';
    }

    hideAutoComplete() {
        this.autoCompleteDropdown.style.display = 'none';
        this.selectedAutoCompleteIndex = -1;
    }

    navigateAutoComplete(direction) {
        const items = this.autoCompleteDropdown.querySelectorAll('.auto-complete-item');
        if (items.length === 0) return;

        // Remove previous selection
        if (this.selectedAutoCompleteIndex >= 0) {
            items[this.selectedAutoCompleteIndex].classList.remove('selected');
        }

        // Update selection
        this.selectedAutoCompleteIndex += direction;
        if (this.selectedAutoCompleteIndex < 0) {
            this.selectedAutoCompleteIndex = items.length - 1;
        } else if (this.selectedAutoCompleteIndex >= items.length) {
            this.selectedAutoCompleteIndex = 0;
        }

        // Apply new selection
        items[this.selectedAutoCompleteIndex].classList.add('selected');
    }

    selectAutoCompleteItem(index) {
        const contact = this.autoCompleteItems[index];
        if (contact) {
            this.currentNumber = contact.numbers[0];
            this.dialerInput.value = this.currentNumber;
            this.updateDisplay();
            this.hideAutoComplete();
            this.showToast(`Selected: ${contact.name}`, 'info');
        }
    }

    // DTMF functionality
    toggleDTMF() {
        this.dtmfEnabled = !this.dtmfEnabled;
        this.dtmfEnabledText.textContent = this.dtmfEnabled ? 'Enabled' : 'Disabled';
        this.dtmfIndicator.textContent = this.dtmfEnabled ? 'ðŸ”Š' : 'ðŸ”‡';
        this.showToast(`DTMF tones ${this.dtmfEnabled ? 'enabled' : 'disabled'}`, 'info');
    }

    async testAllDTMFTones() {
        if (!this.dtmfEnabled) {
            this.showToast('DTMF tones are disabled', 'warning');
            return;
        }

        this.showToast('Testing DTMF tones...', 'info');
        const digits = ['1', '2', '3', '4', '5', '6', '7', '8', '9', '*', '0', '#'];

        for (const digit of digits) {
            await this.playDTMFTone(digit);
            await new Promise(resolve => setTimeout(resolve, 300));
        }

        this.showToast('DTMF test completed', 'success');
    }

    // SMS functionality
    openSMS() {
        if (!this.currentNumber) {
            this.showToast('Enter a number first', 'warning');
            return;
        }

        // Create SMS modal/interface
        const smsText = prompt(`Send SMS to ${this.currentNumber}:`);
        if (smsText) {
            this.sendSMS(this.currentNumber, smsText);
        }
    }

    async sendSMS(to, message) {
        try {
            const result = await window.flexPhoneAPI.sms.send(to, message);
            if (result.success) {
                this.showToast(`SMS sent to ${to}`, 'success');
            } else {
                this.showToast(`SMS failed: ${result.error}`, 'error');
            }
        } catch (error) {
            this.showToast(`SMS error: ${error.message}`, 'error');
        }
    }

    // Contact management
    addContact() {
        if (!this.currentNumber) {
            this.showToast('Enter a number first', 'warning');
            return;
        }

        const name = prompt(`Add contact name for ${this.currentNumber}:`);
        if (name) {
            this.saveContact(name, this.currentNumber);
        }
    }

    async saveContact(name, number) {
        try {
            const contact = {
                name: name,
                numbers: [number],
                email: '',
                notes: ''
            };

            const result = await window.flexPhoneAPI.contacts.add(contact);
            if (result.success) {
                this.showToast(`Contact "${name}" added`, 'success');
                await this.loadContacts(); // Reload contacts
            } else {
                this.showToast(`Failed to add contact: ${result.error}`, 'error');
            }
        } catch (error) {
            this.showToast(`Contact error: ${error.message}`, 'error');
        }
    }

    // Enhanced SIP Features

    // Quick dial functions
    dialNumber(number) {
        this.currentNumber = number;
        this.dialerInput.value = this.currentNumber;
        this.updateDisplay();
        this.switchTab('dialer');
    }

    // SIP Clients Management
    async loadSipClients() {
        try {
            // Mock SIP clients data for demonstration
            this.sipClients = [
                {
                    id: '1001',
                    name: 'Reception Desk',
                    userAgent: 'FlexPhone 2.0.1 (macOS)',
                    ipAddress: '192.168.1.100',
                    status: 'online',
                    deviceType: 'desktop',
                    os: 'macOS Monterey',
                    lastSeen: new Date()
                },
                {
                    id: '1002',
                    name: 'Sales Manager',
                    userAgent: 'Zoiper 5.5.1 (Windows)',
                    ipAddress: '192.168.1.101',
                    status: 'busy',
                    deviceType: 'laptop',
                    os: 'Windows 11',
                    lastSeen: new Date()
                },
                {
                    id: '1003',
                    name: 'Tech Support',
                    userAgent: 'MicroSIP 3.21.2',
                    ipAddress: '192.168.1.102',
                    status: 'offline',
                    deviceType: 'phone',
                    os: 'iOS 15.6',
                    lastSeen: new Date(Date.now() - 300000)
                }
            ];

            this.updateSipClientStats();
            this.renderSipClients();

        } catch (error) {
            console.error('Failed to load SIP clients:', error);
        }
    }

    updateSipClientStats() {
        const onlineCount = this.sipClients.filter(c => c.status === 'online').length;
        const busyCount = this.sipClients.filter(c => c.status === 'busy').length;
        const offlineCount = this.sipClients.filter(c => c.status === 'offline').length;

        this.onlineCount.textContent = onlineCount;
        this.busyCount.textContent = busyCount;
        this.offlineCount.textContent = offlineCount;
    }

    renderSipClients() {
        if (this.sipClients.length === 0) {
            this.sipClientsList.innerHTML = '<div class="empty-state">No SIP clients detected</div>';
            return;
        }

        const list = document.createElement('ul');
        list.className = 'list';

        this.sipClients.forEach(client => {
            const item = document.createElement('li');
            item.className = 'list-item';

            const statusIcon = client.status === 'online' ? 'ðŸŸ¢' :
                             client.status === 'busy' ? 'ðŸŸ¡' : 'ðŸ”´';
            const deviceIcon = client.deviceType === 'phone' ? 'ðŸ“±' :
                              client.deviceType === 'laptop' ? 'ðŸ’»' : 'ðŸ–¥ï¸';

            item.innerHTML = `
                <div class="list-item-icon">${deviceIcon}</div>
                <div class="list-item-content">
                    <div class="list-item-title">${client.name} (${client.id})</div>
                    <div class="list-item-subtitle">${client.userAgent} â€¢ ${client.ipAddress}</div>
                </div>
                <div class="list-item-meta">
                    ${statusIcon} ${client.status.toUpperCase()}
                </div>
            `;

            item.addEventListener('click', () => {
                this.showClientDetails(client);
            });

            list.appendChild(item);
        });

        this.sipClientsList.innerHTML = '';
        this.sipClientsList.appendChild(list);
    }

    showClientDetails(client) {
        const details = `
Client: ${client.name}
Extension: ${client.id}
IP Address: ${client.ipAddress}
User Agent: ${client.userAgent}
OS: ${client.os}
Device Type: ${client.deviceType}
Status: ${client.status}
Last Seen: ${client.lastSeen.toLocaleString()}
        `;
        alert(details);
    }

    // Intercom functionality
    async sendIntercom() {
        const message = this.intercomMessage.value.trim();
        if (!message) {
            this.showToast('Enter a message to send', 'warning');
            return;
        }

        try {
            // Mock intercom send
            this.showToast(`Intercom sent: "${message}"`, 'success');
            this.intercomMessage.value = '';
            console.log(`ðŸ“¢ Intercom message sent: ${message}`);
        } catch (error) {
            this.showToast(`Intercom error: ${error.message}`, 'error');
        }
    }

    async sendQuickIntercom(message) {
        try {
            this.showToast(`Quick intercom: "${message}"`, 'success');
            console.log(`ðŸ“¢ Quick intercom sent: ${message}`);
        } catch (error) {
            this.showToast(`Intercom error: ${error.message}`, 'error');
        }
    }

    // Enhanced settings save
    async saveAllSettings() {
        try {
            // Save basic SIP settings
            await window.flexPhoneAPI.settings.set('sip.provider', this.sipProvider.value);
            await window.flexPhoneAPI.settings.set('sip.server', this.sipServer.value);
            await window.flexPhoneAPI.settings.set('sip.port', parseInt(this.sipPort.value));
            await window.flexPhoneAPI.settings.set('sip.username', this.sipUsername.value);
            await window.flexPhoneAPI.settings.set('sip.password', this.sipPassword.value);
            await window.flexPhoneAPI.settings.set('sip.displayName', this.sipDisplayName.value);

            // Save advanced settings
            await window.flexPhoneAPI.settings.set('sip.autoAnswer', this.autoAnswerEnabled.checked);
            await window.flexPhoneAPI.settings.set('sip.autoAnswerDelay', parseInt(this.autoAnswerDelay.value));
            await window.flexPhoneAPI.settings.set('sip.handsFree', this.handsFreeMode.checked);
            await window.flexPhoneAPI.settings.set('sip.intercom', this.intercomEnabled.checked);
            await window.flexPhoneAPI.settings.set('sip.flexPhoneIntegration', this.flexPhoneIntegration.checked);

            this.showToast('All settings saved successfully', 'success');

        } catch (error) {
            this.showToast(`Settings save error: ${error.message}`, 'error');
        }
    }

    // Auto-answer functionality
    async handleIncomingCall(call) {
        this.currentCall = call.id;

        // Start caller ID announcement with ringtone ducking
        this.startCallerIDRingtone(call);

        if (this.autoAnswerEnabled.checked) {
            const delay = parseInt(this.autoAnswerDelay.value) * 1000;
            this.showToast(`Auto-answering in ${this.autoAnswerDelay.value} seconds...`, 'info');

            setTimeout(async () => {
                try {
                    this.stopCallerIDRingtone();
                    await this.answerCall();
                    this.showToast('Call auto-answered', 'success');
                } catch (error) {
                    this.showToast(`Auto-answer failed: ${error.message}`, 'error');
                }
            }, delay);
        } else {
            this.showIncomingCallOverlay(call);
        }
    }

    async startCallerIDRingtone(call) {
        // Start ringtone with caller ID ducking
        this.isRingtoneActive = true;
        this.ringtoneInterval = null;
        this.callerIDAnnounced = false;

        // Play initial incoming call sound
        await this.voicePack.playIncomingCall();

        // Start ringtone loop with caller ID announcements
        this.playRingtoneWithCallerID(call);
    }

    async playRingtoneWithCallerID(call) {
        if (!this.isRingtoneActive) return;

        try {
            // Play ringtone (traditional phone ring)
            const ringTone = this.audioContext.createOscillator();
            const ringGain = this.audioContext.createGain();

            ringTone.frequency.setValueAtTime(440, this.audioContext.currentTime);
            ringTone.frequency.setValueAtTime(480, this.audioContext.currentTime + 0.4);
            ringGain.gain.setValueAtTime(0.3, this.audioContext.currentTime);
            ringGain.gain.setValueAtTime(0, this.audioContext.currentTime + 0.8);

            ringTone.connect(ringGain);
            ringGain.connect(this.audioContext.destination);

            ringTone.start(this.audioContext.currentTime);
            ringTone.stop(this.audioContext.currentTime + 0.8);

            // Announce caller ID after the first ring
            if (!this.callerIDAnnounced && call.remoteNumber) {
                this.callerIDAnnounced = true;

                // Wait for ring to finish, then duck audio and announce
                setTimeout(async () => {
                    if (this.isRingtoneActive) {
                        // Duck the next ringtone
                        await this.announceCallerIDWithDucking(call.remoteNumber);
                    }
                }, 1000);
            }

            // Continue ringing every 4 seconds
            if (this.isRingtoneActive) {
                this.ringtoneTimeout = setTimeout(() => {
                    this.playRingtoneWithCallerID(call);
                }, 4000);
            }

        } catch (error) {
            console.error('Failed to play ringtone:', error);
        }
    }

    async announceCallerIDWithDucking(phoneNumber) {
        if (!this.isRingtoneActive) return;

        try {
            // Duck any background audio (reduce volume)
            const originalVolume = this.outputVolume;
            this.outputVolume = originalVolume * 0.3; // Duck to 30%

            // Announce the caller ID
            await this.voicePack.announceCallerID(phoneNumber);

            // Restore original volume
            this.outputVolume = originalVolume;

        } catch (error) {
            console.error('Failed to announce caller ID with ducking:', error);
            // Restore volume on error
            this.outputVolume = originalVolume;
        }
    }

    stopCallerIDRingtone() {
        this.isRingtoneActive = false;

        if (this.ringtoneTimeout) {
            clearTimeout(this.ringtoneTimeout);
            this.ringtoneTimeout = null;
        }

        this.callerIDAnnounced = false;
    }

    // ===== CALL HOLD AND MERGE FUNCTIONALITY =====

    holdCurrentCallForSecondCall() {
        if (!this.currentCall) return;

        console.log('ðŸ”„ Holding current call for second call...');

        // Track call hold with PBX
        this.trackCallHeld({
            id: this.currentCall.id,
            number: this.currentNumber,
            heldAt: Date.now()
        });

        // Move current call to held calls
        this.pbxCallStates.heldCalls.push(this.currentCall);
        this.currentCall = null;

        // Start hold music (default or none based on settings)
        this.startHoldMusicForHeldCall();

        // Start dial tone for new call
        this.startDialTone();

        // Clear current number for new dialing
        this.currentNumber = '';
        this.updateDisplay();

        // Announce the action
        this.speakAction('Call on hold. Dial second number to merge calls');
        this.showToast('Call on hold - Ready for second call', 'info');

        console.log('âœ… Call held successfully, ready for second call');
    }

    makeCallAndMerge() {
        if (!this.currentNumber || this.pbxCallStates.heldCalls.length === 0) return;

        console.log('ðŸ“ž Making second call to merge with held call...');

        // Stop dial tone
        this.stopDialTone();

        // Make the second call
        this.makeRegularSIPCall();

        // Set up for automatic merge once second call connects
        this.waitingToMerge = true;

        this.speakAction(`Calling ${this.currentNumber} to merge with held call`);
        this.showToast('Connecting second call for merge...', 'info');
    }

    startHoldMusicForHeldCall() {
        // Get hold music settings
        const holdMusicEnabled = localStorage.getItem('holdMusicEnabled') !== 'false';

        if (!holdMusicEnabled) {
            console.log('ðŸ”‡ Hold music disabled - silent hold');
            return;
        }

        // Use default hold music or user's selected music
        const selectedHoldMusic = localStorage.getItem('selectedHoldMusic') || 'default';

        if (selectedHoldMusic === 'default') {
            this.playDefaultHoldMusic();
        } else {
            this.playCustomHoldMusic(selectedHoldMusic);
        }

        console.log(`ðŸŽµ Started hold music: ${selectedHoldMusic}`);
    }

    playDefaultHoldMusic() {
        // Play a simple, pleasant hold tone sequence
        const holdTones = [
            { frequency: 523, duration: 800 }, // C5
            { frequency: 659, duration: 800 }, // E5
            { frequency: 523, duration: 800 }, // C5
            { frequency: 392, duration: 1200 } // G4 (longer)
        ];

        let currentTone = 0;
        const playHoldTone = () => {
            if (!this.pbxCallStates.heldCalls.length) return; // Stop if no held calls

            const tone = holdTones[currentTone % holdTones.length];
            this.playTone(tone.frequency, tone.duration, 0.08); // Very low volume

            currentTone++;
            setTimeout(playHoldTone, tone.duration + 500); // Gap between tones
        };

        // Start the hold music loop
        setTimeout(playHoldTone, 500);
    }

    playCustomHoldMusic(musicFile) {
        // This would play custom hold music files
        // For now, fall back to default
        console.log(`ðŸŽµ Custom hold music not yet implemented: ${musicFile}`);
        this.playDefaultHoldMusic();
    }

    // Enhanced playTone method with volume control
    playTone(frequency, duration, volume = 0.2) {
        if (!this.audioContext) return;

        try {
            const oscillator = this.audioContext.createOscillator();
            const gainNode = this.audioContext.createGain();

            oscillator.frequency.setValueAtTime(frequency, this.audioContext.currentTime);
            oscillator.type = 'sine';

            gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
            gainNode.gain.linearRampToValueAtTime(volume, this.audioContext.currentTime + 0.05);
            gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + (duration / 1000) - 0.05);

            oscillator.connect(gainNode);
            gainNode.connect(this.audioContext.destination);

            oscillator.start(this.audioContext.currentTime);
            oscillator.stop(this.audioContext.currentTime + (duration / 1000));
        } catch (error) {
            console.error('Failed to play tone:', error);
        }
    }

    // ===== QUEUE MANAGEMENT SYSTEM =====

    toggleQueueStatus() {
        // Check queue system availability
        if (!this.isQueueSystemAvailable()) {
            this.speakAction('Queue management not available');
            this.showToast('No queue systems configured', 'warning');
            return;
        }

        // Toggle queue status based on current state
        switch (this.queueStatus) {
            case 'logged-out':
                this.loginToQueues();
                break;
            case 'logged-in':
                this.logoutFromQueues();
                break;
            case 'paused':
                this.unpauseQueues();
                break;
        }
    }

    isQueueSystemAvailable() {
        // FlexPBX is always available when connected
        if (this.isFlexPBXConnected()) {
            return true;
        }

        // Check if third-party queue systems are enabled and available
        if (this.queueSystemSettings.thirdPartyEnabled) {
            const enabledSystems = this.queueSystemSettings.availableSystems.filter(s => s.enabled && s.id !== 'flexpbx');
            return enabledSystems.length > 0;
        }

        return false;
    }

    getCurrentQueueSystem() {
        // FlexPBX takes priority when connected
        if (this.isFlexPBXConnected()) {
            return 'flexpbx';
        }

        // Return first enabled third-party system
        if (this.queueSystemSettings.thirdPartyEnabled) {
            const enabledSystem = this.queueSystemSettings.availableSystems.find(s => s.enabled && s.id !== 'flexpbx');
            return enabledSystem ? enabledSystem.id : this.queueSystemSettings.defaultSystem;
        }

        return this.queueSystemSettings.defaultSystem;
    }

    isFlexPBXConnected() {
        // Check if we're connected to a FlexPBX server
        if (!this.isConnected || !this.sipServer) return false;

        const server = this.sipServer.value.toLowerCase();
        return server.includes('flexpbx') || server.includes('flexphone');
    }

    async loginToQueues() {
        const currentSystem = this.getCurrentQueueSystem();
        console.log(`ðŸ”— Logging into queues using ${currentSystem}...`);

        try {
            if (currentSystem === 'flexpbx') {
                // FlexPBX queue system
                await this.fetchAvailableQueues();
            } else {
                // Third-party queue system
                await this.fetchThirdPartyQueues(currentSystem);
            }

            if (this.availableQueues.length === 0) {
                this.speakAction(`No queues available on ${currentSystem}`);
                this.showToast('No queues available', 'warning');
                return;
            }

            // If only one queue, auto-join it
            if (this.availableQueues.length === 1) {
                await this.joinQueue(this.availableQueues[0], currentSystem);
            } else {
                // Show queue selection dialog
                this.showQueueSelectionDialog(currentSystem);
            }

        } catch (error) {
            console.error('Failed to login to queues:', error);
            this.speakAction(`Failed to login to ${currentSystem} queues`);
            this.showToast('Queue login failed', 'error');
        }
    }

    async logoutFromQueues() {
        console.log('ðŸ”— Logging out from queues...');

        try {
            // Logout from all joined queues
            for (const queue of this.joinedQueues) {
                await this.leaveQueue(queue);
            }

            this.queueStatus = 'logged-out';
            this.joinedQueues = [];

            // Report to PBX
            this.reportToPBX('queue', {
                action: 'logout',
                queues: [],
                status: 'logged-out',
                timestamp: Date.now()
            });

            this.speakAction('Logged out from all queues');
            this.showToast('F7: Queue logged out', 'success');

        } catch (error) {
            console.error('Failed to logout from queues:', error);
            this.speakAction('Failed to logout from queues');
            this.showToast('Queue logout failed', 'error');
        }
    }

    async pauseQueues() {
        if (this.queueStatus !== 'logged-in') return;

        console.log('â¸ï¸ Pausing queue membership...');

        try {
            this.queueStatus = 'paused';

            // Report to PBX
            this.reportToPBX('queue', {
                action: 'pause',
                queues: this.joinedQueues,
                status: 'paused',
                timestamp: Date.now()
            });

            this.speakAction('Queue paused - not receiving calls');
            this.showToast('F7: Queue paused', 'info');

        } catch (error) {
            console.error('Failed to pause queues:', error);
        }
    }

    async unpauseQueues() {
        if (this.queueStatus !== 'paused') return;

        console.log('â–¶ï¸ Unpausing queue membership...');

        try {
            this.queueStatus = 'logged-in';

            // Report to PBX
            this.reportToPBX('queue', {
                action: 'unpause',
                queues: this.joinedQueues,
                status: 'logged-in',
                timestamp: Date.now()
            });

            this.speakAction('Queue unpaused - receiving calls');
            this.showToast('F7: Queue active', 'success');

        } catch (error) {
            console.error('Failed to unpause queues:', error);
        }
    }

    async fetchAvailableQueues() {
        // Fetch queues available for this extension
        if (!this.isFlexPBXConnected()) return;

        try {
            const response = await fetch(`http://${this.sipServer.value}:8080/api/v1/queues/available`, {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json',
                    'X-FlexPhone-Client': 'FlexPhone-v1.0',
                    'X-Extension': this.sipUsername?.value || 'unknown'
                }
            });

            if (response.ok) {
                const data = await response.json();
                this.availableQueues = data.queues || [];
                console.log('ðŸ“‹ Available queues:', this.availableQueues);
            } else {
                // Fallback to default queues if API not available
                this.availableQueues = [
                    { id: 'support', name: 'Support Queue', priority: 1 },
                    { id: 'sales', name: 'Sales Queue', priority: 2 }
                ];
            }
        } catch (error) {
            console.error('Failed to fetch queues:', error);
            // Use fallback queues
            this.availableQueues = [
                { id: 'support', name: 'Support Queue', priority: 1 }
            ];
        }
    }

    async joinQueue(queue) {
        console.log(`ðŸ”— Joining queue: ${queue.name || queue.id}`);

        try {
            // Join the queue via FlexPBX API
            const response = await fetch(`http://${this.sipServer.value}:8080/api/v1/queues/join`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-FlexPhone-Client': 'FlexPhone-v1.0',
                    'X-Extension': this.sipUsername?.value || 'unknown'
                },
                body: JSON.stringify({
                    extension: this.sipUsername?.value || 'unknown',
                    queueId: queue.id,
                    priority: queue.priority || 1
                })
            });

            if (response.ok || response.status === 404) { // Accept 404 as API might not exist yet
                this.joinedQueues.push(queue);
                this.queueStatus = 'logged-in';

                // Report to PBX
                this.reportToPBX('queue', {
                    action: 'join',
                    queue: queue,
                    queues: this.joinedQueues,
                    status: 'logged-in',
                    timestamp: Date.now()
                });

                this.speakAction(`Joined queue: ${queue.name || queue.id}`);
                this.showToast(`F7: Queue logged in - ${queue.name || queue.id}`, 'success');
            } else {
                throw new Error(`Failed to join queue: ${response.status}`);
            }

        } catch (error) {
            console.error('Failed to join queue:', error);
            this.speakAction('Failed to join queue');
            this.showToast('Queue join failed', 'error');
        }
    }

    async leaveQueue(queue) {
        console.log(`ðŸ”— Leaving queue: ${queue.name || queue.id}`);

        try {
            // Leave the queue via FlexPBX API
            const response = await fetch(`http://${this.sipServer.value}:8080/api/v1/queues/leave`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-FlexPhone-Client': 'FlexPhone-v1.0',
                    'X-Extension': this.sipUsername?.value || 'unknown'
                },
                body: JSON.stringify({
                    extension: this.sipUsername?.value || 'unknown',
                    queueId: queue.id
                })
            });

            // Remove from joined queues regardless of API response
            this.joinedQueues = this.joinedQueues.filter(q => q.id !== queue.id);

        } catch (error) {
            console.error('Failed to leave queue:', error);
        }
    }

    showQueueSelectionDialog() {
        // Create queue selection dialog
        const dialog = document.createElement('div');
        dialog.className = 'queue-selection-dialog';
        dialog.style.cssText = `
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
        `;

        let queueOptions = '';
        this.availableQueues.forEach((queue, index) => {
            queueOptions += `
                <div class="queue-option" data-queue-id="${queue.id}" tabindex="0" role="option">
                    <strong>${queue.name || queue.id}</strong>
                    <small style="display: block; color: #999;">Priority: ${queue.priority || 1}</small>
                </div>
            `;
        });

        dialog.innerHTML = `
            <div style="
                background: linear-gradient(135deg, #1e1e1e 0%, #2d2d2d 100%);
                border-radius: 8px;
                padding: 24px;
                min-width: 400px;
                max-width: 500px;
                color: white;
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            ">
                <h3 style="margin: 0 0 16px 0; color: #4CAF50;">
                    ðŸ”— Select Queue to Join
                </h3>
                <div class="queue-list" role="listbox" style="
                    max-height: 300px;
                    overflow-y: auto;
                    border: 1px solid #555;
                    border-radius: 4px;
                    background: #333;
                ">
                    ${queueOptions}
                </div>
                <div style="margin-top: 20px; text-align: right;">
                    <button class="btn-cancel">Cancel</button>
                    <button class="btn-join" style="margin-left: 8px;">Join Queue</button>
                </div>
            </div>
        `;

        // Add event handlers
        let selectedQueue = null;

        dialog.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                e.preventDefault();
                document.body.removeChild(dialog);
            }
        });

        dialog.querySelector('.btn-cancel').addEventListener('click', () => {
            document.body.removeChild(dialog);
        });

        dialog.querySelector('.btn-join').addEventListener('click', () => {
            if (selectedQueue) {
                this.joinQueue(selectedQueue);
            }
            document.body.removeChild(dialog);
        });

        dialog.querySelectorAll('.queue-option').forEach(option => {
            option.addEventListener('click', () => {
                dialog.querySelectorAll('.queue-option').forEach(opt => {
                    opt.style.background = '';
                });
                option.style.background = '#4CAF50';
                const queueId = option.dataset.queueId;
                selectedQueue = this.availableQueues.find(q => q.id === queueId);
            });
        });

        document.body.appendChild(dialog);

        // Focus first queue option
        const firstOption = dialog.querySelector('.queue-option');
        if (firstOption) {
            firstOption.focus();
        }

        this.speakAction(`Queue selection opened. ${this.availableQueues.length} queues available`);
    }

    // ===== THIRD-PARTY QUEUE SYSTEM INTEGRATION =====

    async authenticateAccessibilityAPI() {
        if (this.apiKey) return true; // Already authenticated

        try {
            const response = await fetch(`${this.queueSystemSettings.accessibilityApiUrl}/auth`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    application_name: 'FlexPhone Desktop Client',
                    version: '1.0',
                    accessibility_type: 'desktop_client',
                    requested_permissions: ['call_control', 'status_monitoring', 'queue_management']
                })
            });

            const data = await response.json();
            this.apiKey = data.api_key;
            console.log('âœ… Accessibility API authenticated');
            return true;
        } catch (error) {
            console.error('âŒ Failed to authenticate with accessibility API:', error);
            return false;
        }
    }

    async fetchThirdPartyQueues(system) {
        if (!await this.authenticateAccessibilityAPI()) {
            throw new Error('Failed to authenticate with accessibility API');
        }

        try {
            const response = await fetch(`${this.queueSystemSettings.accessibilityApiUrl}/queue-systems/${system}/status`, {
                headers: { 'Authorization': `Bearer ${this.apiKey}` }
            });

            const data = await response.json();
            this.availableQueues = data.queues || [];
            console.log(`ðŸ“Š Fetched ${this.availableQueues.length} queues from ${system}`);
        } catch (error) {
            console.error(`âŒ Failed to fetch ${system} queues:`, error);
            this.availableQueues = [];
        }
    }

    async joinQueue(queue, system = 'flexpbx') {
        if (system === 'flexpbx') {
            return this.joinFlexPBXQueue(queue);
        } else {
            return this.joinThirdPartyQueue(queue, system);
        }
    }

    async joinFlexPBXQueue(queue) {
        // Original FlexPBX queue join logic
        try {
            const response = await fetch(`http://${this.sipServer.value}:8080/api/v1/queues/join`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-FlexPhone-Client': 'FlexPhone-v1.0',
                    'X-Extension': this.sipUsername?.value || 'unknown'
                },
                body: JSON.stringify({
                    extension: this.sipUsername?.value || 'unknown',
                    queue_id: queue.id,
                    priority: queue.priority || 1
                })
            });

            if (response.ok) {
                this.joinedQueues.push(queue);
                this.queueStatus = 'logged-in';
                this.speakAction(`Joined FlexPBX queue ${queue.name}`);
                this.showToast(`F7: Joined queue ${queue.name}`, 'success');
                this.reportToPBX('queue', {
                    action: 'join',
                    queue: queue,
                    status: 'logged-in',
                    timestamp: Date.now()
                });
            } else {
                throw new Error('Queue join failed');
            }
        } catch (error) {
            console.error('Failed to join FlexPBX queue:', error);
            throw error;
        }
    }

    async joinThirdPartyQueue(queue, system) {
        if (!await this.authenticateAccessibilityAPI()) {
            throw new Error('Failed to authenticate with accessibility API');
        }

        try {
            const response = await fetch(`${this.queueSystemSettings.accessibilityApiUrl}/queue-systems/${system}/login`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${this.apiKey}`
                },
                body: JSON.stringify({
                    extension: this.sipUsername?.value || 'unknown',
                    queue_id: queue.id,
                    priority: queue.priority || 1,
                    announce: true
                })
            });

            if (response.ok) {
                this.joinedQueues.push(queue);
                this.queueStatus = 'logged-in';
                const systemName = this.queueSystemSettings.availableSystems.find(s => s.id === system)?.name || system;
                this.speakAction(`Joined ${systemName} queue ${queue.name}`);
                this.showToast(`F7: Joined ${systemName} queue ${queue.name}`, 'success');
                console.log(`âœ… Joined ${system} queue: ${queue.name}`);
            } else {
                throw new Error(`${system} queue join failed`);
            }
        } catch (error) {
            console.error(`Failed to join ${system} queue:`, error);
            throw error;
        }
    }

    async leaveQueue(queue, system = 'flexpbx') {
        if (system === 'flexpbx') {
            return this.leaveFlexPBXQueue(queue);
        } else {
            return this.leaveThirdPartyQueue(queue, system);
        }
    }

    async leaveFlexPBXQueue(queue) {
        // Original FlexPBX queue leave logic
        try {
            const response = await fetch(`http://${this.sipServer.value}:8080/api/v1/queues/leave`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-FlexPhone-Client': 'FlexPhone-v1.0',
                    'X-Extension': this.sipUsername?.value || 'unknown'
                },
                body: JSON.stringify({
                    extension: this.sipUsername?.value || 'unknown',
                    queue_id: queue.id
                })
            });

            if (response.ok) {
                console.log(`âœ… Left FlexPBX queue: ${queue.name}`);
            }
        } catch (error) {
            console.error('Failed to leave FlexPBX queue:', error);
        }
    }

    async leaveThirdPartyQueue(queue, system) {
        if (!this.apiKey) return;

        try {
            const response = await fetch(`${this.queueSystemSettings.accessibilityApiUrl}/queue-systems/${system}/logout`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${this.apiKey}`
                },
                body: JSON.stringify({
                    extension: this.sipUsername?.value || 'unknown',
                    queue_id: queue.id,
                    announce: true
                })
            });

            if (response.ok) {
                console.log(`âœ… Left ${system} queue: ${queue.name}`);
            }
        } catch (error) {
            console.error(`Failed to leave ${system} queue:`, error);
        }
    }

    // ===== PBX STATUS MONITORING SYSTEM =====

    initializePBXStatusReporting() {
        console.log('ðŸ”— Initializing PBX status reporting system...');

        // Start periodic status updates
        this.pbxStatusInterval = setInterval(() => {
            this.updatePBXStatus();
        }, 5000); // Update every 5 seconds

        // Report initial status
        setTimeout(() => {
            this.reportToPBX('presence', { status: 'online', timestamp: Date.now() });
        }, 2000);
    }

    updatePBXStatus() {
        this.pbxCallStates.lastStatusUpdate = Date.now();

        // Determine current user status based on call state
        let userStatus = 'available';
        if (this.currentCall) {
            userStatus = 'busy';
        } else if (this.pbxCallStates.heldCalls.length > 0) {
            userStatus = 'busy'; // Still busy even if calls are on hold
        } else if (this.pbxCallStates.incomingCalls.length > 0) {
            userStatus = 'ringing';
        }

        this.pbxCallStates.userStatus = userStatus;

        // Report to PBX if status changed
        this.reportToPBX('status', {
            userStatus: userStatus,
            activeCall: this.currentCall ? {
                id: this.currentCall.id || 'unknown',
                number: this.currentNumber,
                direction: this.currentCall.direction || 'unknown',
                duration: this.currentCall.startTime ? Date.now() - this.currentCall.startTime : 0
            } : null,
            heldCallsCount: this.pbxCallStates.heldCalls.length,
            incomingCallsCount: this.pbxCallStates.incomingCalls.length,
            recordingActive: this.pbxCallStates.recordingActive,
            timestamp: Date.now()
        });
    }

    async reportToPBX(endpoint, data) {
        if (!this.isConnected || !this.sipServer) return;

        try {
            const pbxUrl = this.sipServer.value.includes('flexpbx')
                ? `http://${this.sipServer.value}:8080${this.pbxAPIEndpoints[endpoint] || this.pbxAPIEndpoints.statusUpdate}`
                : null;

            if (!pbxUrl) return; // Only report to FlexPBX systems

            const response = await fetch(pbxUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-FlexPhone-Client': 'FlexPhone-v1.0',
                    'X-Extension': this.sipUsername?.value || 'unknown'
                },
                body: JSON.stringify({
                    extension: this.sipUsername?.value || 'unknown',
                    clientId: this.generateClientId(),
                    ...data
                })
            });

            if (response.ok) {
                console.log(`âœ… PBX ${endpoint} update sent successfully`);
            } else {
                console.warn(`âš ï¸ PBX ${endpoint} update failed:`, response.status);
            }
        } catch (error) {
            console.error(`âŒ Failed to report to PBX (${endpoint}):`, error.message);
        }
    }

    generateClientId() {
        return `FlexPhone-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    }

    // Call state tracking methods
    trackCallStarted(callInfo) {
        this.pbxCallStates.activeCall = {
            id: callInfo.id || this.generateCallId(),
            number: callInfo.number || this.currentNumber,
            direction: callInfo.direction || 'outgoing',
            startTime: Date.now()
        };

        this.reportToPBX('callState', {
            event: 'call_started',
            call: this.pbxCallStates.activeCall,
            timestamp: Date.now()
        });
    }

    trackCallEnded(callInfo) {
        if (this.pbxCallStates.activeCall) {
            const call = this.pbxCallStates.activeCall;
            call.endTime = Date.now();
            call.duration = call.endTime - call.startTime;

            this.reportToPBX('callState', {
                event: 'call_ended',
                call: call,
                timestamp: Date.now()
            });

            this.pbxCallStates.activeCall = null;
        }
    }

    trackCallHeld(callInfo) {
        if (this.pbxCallStates.activeCall) {
            this.pbxCallStates.heldCalls.push(this.pbxCallStates.activeCall);
            this.pbxCallStates.activeCall = null;

            this.reportToPBX('callState', {
                event: 'call_held',
                call: callInfo,
                heldCallsCount: this.pbxCallStates.heldCalls.length,
                timestamp: Date.now()
            });
        }
    }

    trackCallResumed(callInfo) {
        if (this.pbxCallStates.heldCalls.length > 0) {
            const heldCall = this.pbxCallStates.heldCalls.shift();
            this.pbxCallStates.activeCall = heldCall;

            this.reportToPBX('callState', {
                event: 'call_resumed',
                call: heldCall,
                heldCallsCount: this.pbxCallStates.heldCalls.length,
                timestamp: Date.now()
            });
        }
    }

    trackRecordingStarted() {
        this.pbxCallStates.recordingActive = true;
        this.reportToPBX('callState', {
            event: 'recording_started',
            call: this.pbxCallStates.activeCall,
            timestamp: Date.now()
        });
    }

    trackRecordingStopped() {
        this.pbxCallStates.recordingActive = false;
        this.reportToPBX('callState', {
            event: 'recording_stopped',
            call: this.pbxCallStates.activeCall,
            timestamp: Date.now()
        });
    }

    generateCallId() {
        return `call-${Date.now()}-${Math.random().toString(36).substr(2, 6)}`;
    }

    // Fix test tones to not announce, just play
    playTestTones() {
        console.log('ðŸŽµ Playing test tones...');

        // Play test tones without any announcements
        const testTones = [
            { frequency: 440, duration: 500 }, // A4
            { frequency: 523, duration: 500 }, // C5
            { frequency: 659, duration: 500 }, // E5
            { frequency: 784, duration: 500 }  // G5
        ];

        testTones.forEach((tone, index) => {
            setTimeout(() => {
                this.playTone(tone.frequency, tone.duration);
            }, index * 600);
        });
    }

}

// Global functions for quick dial buttons
function dialNumber(number) {
    if (window.flexPhoneApp) {
        window.flexPhoneApp.dialNumber(number);
    }
}

function sendQuickIntercom(message) {
    if (window.flexPhoneApp) {
        window.flexPhoneApp.sendQuickIntercom(message);
    }
}

// ===== VOICEPACK AUDIO SYSTEM =====
// High-quality voice prompts and audio feedback system

class VoicePackManager {
    constructor(parentApp) {
        this.parentApp = parentApp;
        this.enabled = true;
        this.volume = 0.8;
        this.currentPack = 'VoicePack01';
        this.audioCache = new Map();
        this.audioSettings = this.loadAudioSettings();

        // Audio file mappings
        this.voicePackFiles = {
            // DTMF Digits
            '0': '0.wav', '1': '1.wav', '2': '2.wav', '3': '3.wav', '4': '4.wav',
            '5': '5.wav', '6': '6.wav', '7': '7.wav', '8': '8.wav', '9': '9.wav',
            '*': '_.wav', '#': '#.wav', '+': '+.wav', 'O': 'O.wav',

            // System Events
            'ready': 'FlexPhoneReady.wav',
            'call_incoming': 'CallIncoming.wav',
            'call_from': 'CallFrom.wav',
            'call_ending': 'CallEnding.wav',
            'call_goodbye1': 'CallGoodbuy01.wav',
            'call_goodbye2': 'CallGoodBuy02.wav',
            'not_in_service': 'NotInService.wav',

            // Volume Controls
            'volume_up': 'VolumeUp.wav',
            'volume_down': 'VolumeDown.wav',
            'volume_louder': 'VolumeLouder.wav',
            'volume_softer': 'VolumeSofter.wav'
        };

        // Action-specific audio settings
        this.actionSettings = {
            'f1_pickup': {
                enabled: true,
                sound: 'ready',
                inputVolume: 0.8,
                outputVolume: 0.8,
                description: 'Phone pickup sound'
            },
            'f2_hangup': {
                enabled: true,
                sound: 'call_ending',
                inputVolume: 0.8,
                outputVolume: 0.8,
                description: 'Call ending sound'
            },
            'f3_hold': {
                enabled: true,
                sound: 'not_in_service',
                inputVolume: 0.6,
                outputVolume: 0.6,
                description: 'Hold notification'
            },
            'f11_volume_down': {
                enabled: true,
                sound: 'volume_down',
                inputVolume: 0.7,
                outputVolume: 0.9,
                description: 'Volume down feedback'
            },
            'f12_volume_up': {
                enabled: true,
                sound: 'volume_up',
                inputVolume: 0.7,
                outputVolume: 0.9,
                description: 'Volume up feedback'
            },
            'dtmf_digit': {
                enabled: true,
                sound: 'dynamic',
                inputVolume: 0.8,
                outputVolume: 0.8,
                description: 'DTMF digit feedback'
            },
            'incoming_call': {
                enabled: true,
                sound: 'call_incoming',
                inputVolume: 0.9,
                outputVolume: 0.9,
                description: 'Incoming call alert'
            }
        };

        this.preloadAudioFiles();
    }

    async preloadAudioFiles() {
        console.log('ðŸŽµ Preloading VoicePack audio files...');

        for (const [key, filename] of Object.entries(this.voicePackFiles)) {
            try {
                const audio = new Audio();
                const path = `./assets/sounds/${this.currentPack}/${filename}`;
                audio.src = path;
                audio.preload = 'auto';
                audio.volume = this.volume;

                // Handle loading
                audio.addEventListener('canplaythrough', () => {
                    console.log(`âœ… Loaded: ${filename}`);
                });

                audio.addEventListener('error', (e) => {
                    console.warn(`âš ï¸ Failed to load: ${filename}`, e);
                });

                this.audioCache.set(key, audio);
            } catch (error) {
                console.warn(`Failed to preload ${filename}:`, error);
            }
        }
    }

    loadAudioSettings() {
        try {
            const saved = localStorage.getItem('flexphone_voicepack_settings');
            return saved ? JSON.parse(saved) : {};
        } catch (error) {
            return {};
        }
    }

    saveAudioSettings() {
        try {
            localStorage.setItem('flexphone_voicepack_settings', JSON.stringify(this.audioSettings));
        } catch (error) {
            console.error('Failed to save VoicePack settings:', error);
        }
    }

    async playActionSound(actionKey, options = {}) {
        if (!this.enabled) return;

        const settings = this.actionSettings[actionKey];
        if (!settings || !settings.enabled) return;

        // Handle default (system beeps) mode
        if (this.currentPack === 'default') {
            this.playDefaultBeep(actionKey, options);
            return;
        }

        let soundKey = settings.sound;

        // Handle dynamic sounds (like DTMF digits)
        if (soundKey === 'dynamic' && options.digit) {
            soundKey = options.digit.toString();
        }

        await this.playSound(soundKey, {
            volume: options.volume || settings.outputVolume || this.volume,
            inputVolume: settings.inputVolume,
            ...options
        });
    }

    async playSound(soundKey, options = {}) {
        if (!this.enabled || !this.audioCache.has(soundKey)) {
            console.warn(`Sound not found: ${soundKey}`);
            return;
        }

        try {
            const audio = this.audioCache.get(soundKey);
            audio.volume = options.volume || this.volume;

            // Reset and play
            audio.currentTime = 0;
            await audio.play();

            console.log(`ðŸ”Š Played VoicePack sound: ${soundKey}`);

            // Announce to screen reader if requested
            if (options.announce && this.parentApp.speakAction) {
                this.parentApp.speakAction(options.announceText || `Playing ${soundKey}`);
            }

        } catch (error) {
            console.error(`Failed to play sound ${soundKey}:`, error);
        }
    }

    async playDTMFVoice(digit) {
        await this.playActionSound('dtmf_digit', {
            digit: digit,
            announce: true,
            announceText: `DTMF ${digit}`
        });
    }

    async playF1Pickup() {
        await this.playActionSound('f1_pickup', {
            announce: true,
            announceText: 'Phone pickup'
        });
    }

    async playF2Hangup() {
        await this.playActionSound('f2_hangup', {
            announce: true,
            announceText: 'Call ending'
        });
    }

    async playF3Hold() {
        await this.playActionSound('f3_hold', {
            announce: true,
            announceText: 'Call on hold'
        });
    }

    async playVolumeChange(direction) {
        const actionKey = direction === 'up' ? 'f12_volume_up' : 'f11_volume_down';
        await this.playActionSound(actionKey, {
            announce: true,
            announceText: `Volume ${direction}`
        });
    }

    async playIncomingCall(phoneNumber = null) {
        await this.playActionSound('incoming_call', {
            announce: true,
            announceText: 'Incoming call'
        });

        // Announce caller ID if phone number is provided
        if (phoneNumber) {
            await this.announceCallerID(phoneNumber);
        }
    }

    async announceCallerID(phoneNumber) {
        if (!this.enabled || !phoneNumber) return;

        try {
            // First announce "Call from"
            await this.playSound('call_from');
            await new Promise(resolve => setTimeout(resolve, 500));

            // Clean the phone number (remove non-digits)
            const digits = phoneNumber.replace(/\D/g, '');

            // Announce each digit
            for (let i = 0; i < digits.length; i++) {
                const digit = digits[i];

                if (this.currentPack === 'default') {
                    // For default mode, use speech synthesis
                    this.parentApp.speakAction(digit);
                } else {
                    // For VoicePack, play audio file
                    await this.playSound(digit);
                }

                // Small pause between digits
                if (i < digits.length - 1) {
                    await new Promise(resolve => setTimeout(resolve, 400));
                }
            }

            console.log(`ðŸ”Š Announced caller ID: ${phoneNumber}`);

        } catch (error) {
            console.error('Failed to announce caller ID:', error);
            // Fallback to speech synthesis
            this.parentApp.speakAction(`Call from ${phoneNumber}`);
        }
    }

    async announcePhoneNumber(phoneNumber) {
        // Standalone method to announce any phone number
        if (!phoneNumber) return;

        const digits = phoneNumber.replace(/\D/g, '');

        for (let i = 0; i < digits.length; i++) {
            const digit = digits[i];

            if (this.currentPack === 'default') {
                this.parentApp.speakAction(digit);
                await new Promise(resolve => setTimeout(resolve, 400));
            } else {
                await this.playSound(digit);
                if (i < digits.length - 1) {
                    await new Promise(resolve => setTimeout(resolve, 300));
                }
            }
        }
    }

    async playReady() {
        await this.playSound('ready', {
            announce: true,
            announceText: 'FlexPhone ready'
        });
    }

    toggleEnabled() {
        this.enabled = !this.enabled;
        this.parentApp.speakAction(`VoicePack ${this.enabled ? 'enabled' : 'disabled'}`);
        return this.enabled;
    }

    setVolume(volume) {
        this.volume = Math.max(0, Math.min(1, volume));

        // Update all cached audio volumes
        for (const audio of this.audioCache.values()) {
            audio.volume = this.volume;
        }

        this.parentApp.speakAction(`VoicePack volume set to ${Math.round(this.volume * 100)}%`);
    }

    updateActionSetting(actionKey, setting, value) {
        if (!this.actionSettings[actionKey]) {
            this.actionSettings[actionKey] = {};
        }

        this.actionSettings[actionKey][setting] = value;
        this.saveAudioSettings();

        console.log(`Updated ${actionKey}.${setting} = ${value}`);
    }

    getActionSettings() {
        return this.actionSettings;
    }

    getAvailableSounds() {
        return Object.keys(this.voicePackFiles);
    }

    playDefaultBeep(actionKey, options = {}) {
        // Use the parent app's existing tone generation for default beeps
        if (!this.parentApp.audioContext) return;

        const settings = this.actionSettings[actionKey];
        const volume = (settings?.outputVolume || this.volume) * 0.3; // Lower volume for beeps

        try {
            switch (actionKey) {
                case 'f1_pickup':
                    this.parentApp.playActionTone(0, 0, 'pickup');
                    break;
                case 'f2_hangup':
                    this.parentApp.playActionTone(0, 0, 'hangup');
                    break;
                case 'f3_hold':
                    this.parentApp.playActionTone(600, 100);
                    break;
                case 'f11_volume_down':
                    this.parentApp.playActionTone(250, 80);
                    break;
                case 'f12_volume_up':
                    this.parentApp.playActionTone(350, 80);
                    break;
                case 'dtmf_digit':
                    if (options.digit) {
                        this.parentApp.playDTMFTone(options.digit);
                    }
                    break;
                case 'incoming_call':
                    this.parentApp.playActionTone(440, 200);
                    break;
                default:
                    // Generic beep for other actions
                    this.parentApp.playActionTone(400, 150);
                    break;
            }

            // Announce to screen reader if requested
            if (options.announce && this.parentApp.speakAction) {
                this.parentApp.speakAction(options.announceText || `Beep for ${actionKey}`);
            }

        } catch (error) {
            console.error(`Failed to play default beep for ${actionKey}:`, error);
        }
    }

    // New VoicePack methods for advanced functions

    async playMuteToggle(isMuted) {
        const actionKey = 'mute_toggle';
        const announceText = isMuted ? 'Microphone muted' : 'Microphone unmuted';

        await this.playActionSound(actionKey, {
            announce: true,
            announceText: announceText,
            fallbackTone: isMuted ? 200 : 400
        });
    }

    async playHoldToggle(isOnHold) {
        const actionKey = 'hold_music_toggle';
        const announceText = isOnHold ? 'Call on hold with music' : 'Call resumed';

        await this.playActionSound(actionKey, {
            announce: true,
            announceText: announceText,
            fallbackTone: isOnHold ? 600 : 700
        });
    }

    async playRingtoneToggle(isEnabled) {
        const actionKey = 'ringtone_toggle';
        const announceText = isEnabled ? 'Ringtone enabled' : 'Ringtone disabled';

        await this.playActionSound(actionKey, {
            announce: true,
            announceText: announceText,
            fallbackTone: isEnabled ? 800 : 300
        });
    }

    async playDNDToggle(isEnabled) {
        const actionKey = 'dnd_toggle';
        const announceText = isEnabled ? 'Do Not Disturb enabled' : 'Do Not Disturb disabled';

        await this.playActionSound(actionKey, {
            announce: true,
            announceText: announceText,
            fallbackTone: isEnabled ? 1000 : 500
        });
    }

    async playTransferSound() {
        await this.playActionSound('transfer', {
            announce: true,
            announceText: 'Call transfer initiated',
            fallbackTone: 750
        });
    }

    async playConferenceSound() {
        await this.playActionSound('conference', {
            announce: true,
            announceText: 'Conference call',
            fallbackTone: 900
        });
    }

    async playWelcomeMessage() {
        // Play FlexPhone welcome message using VoicePack
        const actionKey = 'welcome_message';

        try {
            // Use FlexPhoneReady.wav at reduced volume for welcome
            const audio = await this.loadSound('ready');
            if (audio) {
                // Set low volume for welcome message
                const originalVolume = audio.volume;
                audio.volume = 0.3; // Low volume

                audio.play().catch(error => {
                    console.log('Welcome audio playback prevented');
                    // Fallback to speech synthesis
                    this.parentApp.speakAction('FlexPhone ready', { volume: 0.3 });
                });

                // Restore original volume after playback
                audio.addEventListener('ended', () => {
                    audio.volume = originalVolume;
                });
            } else {
                // Fallback to speech synthesis
                this.parentApp.speakAction('FlexPhone ready', { volume: 0.3 });
            }

        } catch (error) {
            console.error('Failed to play welcome message:', error);
            // Silent fallback
            this.parentApp.speakAction('FlexPhone ready', { volume: 0.3 });
        }
    }
}

// ===== P2P AUDIO SYSTEM =====
// WebRTC-based peer-to-peer audio communication inspired by SonoBus

class P2PAudioManager {
    constructor(parentApp) {
        this.parentApp = parentApp;
        this.isHost = false;
        this.isConnected = false;
        this.connections = new Map(); // Store multiple peer connections
        this.localStream = null;
        this.audioContext = null;
        this.audioNodes = new Map();

        // P2P Configuration
        this.iceServers = [
            { urls: 'stun:stun.l.google.com:19302' },
            { urls: 'stun:stun1.l.google.com:19302' }
        ];

        // Audio quality settings
        this.audioCodec = 'opus-64'; // Default
        this.bufferSize = 256;
        this.inputVolume = 0.8;
        this.outputVolume = 0.7;
        this.inputMuted = false;
        this.outputMuted = false;

        // Session info
        this.sessionName = '';
        this.sessionPassword = '';
        this.localIP = 'detecting...';

        this.detectLocalIP();
        this.initializeAudioContext();
    }

    async detectLocalIP() {
        try {
            // Use WebRTC to detect local IP
            const pc = new RTCPeerConnection({ iceServers: [] });
            pc.createDataChannel("");
            const offer = await pc.createOffer();
            await pc.setLocalDescription(offer);

            pc.onicecandidate = (event) => {
                if (event.candidate) {
                    const candidate = event.candidate.candidate;
                    const ipMatch = candidate.match(/(\d+\.\d+\.\d+\.\d+)/);
                    if (ipMatch && !ipMatch[1].startsWith('169.254')) {
                        this.localIP = ipMatch[1];
                        this.updateLocalIPDisplay();
                        pc.close();
                    }
                }
            };
        } catch (error) {
            console.error('Failed to detect local IP:', error);
            this.localIP = 'unavailable';
            this.updateLocalIPDisplay();
        }
    }

    updateLocalIPDisplay() {
        const localIPElement = document.getElementById('localIP');
        if (localIPElement) {
            localIPElement.textContent = this.localIP;
        }
    }

    async initializeAudioContext() {
        try {
            const audioContextOptions = {
                sampleRate: 44100, // Match built-in device default
                latencyHint: 'interactive' // Low latency for real-time audio
            };
            this.audioContext = new (window.AudioContext || window.webkitAudioContext)(audioContextOptions);

            // Set up audio processing chain
            this.gainInputNode = this.audioContext.createGain();
            this.gainOutputNode = this.audioContext.createGain();
            this.gainInputNode.gain.value = this.inputVolume;
            this.gainOutputNode.gain.value = this.outputVolume;

            console.log('P2P Audio context initialized with sample rate:', this.audioContext.sampleRate);
        } catch (error) {
            console.error('Failed to initialize audio context:', error);
        }
    }

    async startSession(isHost = true) {
        try {
            this.isHost = isHost;

            // Get user media with high quality settings
            const constraints = this.getAudioConstraints();
            this.localStream = await navigator.mediaDevices.getUserMedia(constraints);

            if (isHost) {
                this.startHostSession();
            } else {
                await this.joinSession();
            }

            this.updateConnectionStatus('Starting session...', 'connecting');
            this.parentApp.speakAction(isHost ? 'Hosting P2P audio session' : 'Joining P2P audio session');

        } catch (error) {
            console.error('Failed to start P2P session:', error);
            this.updateConnectionStatus('Failed to start session', 'error');
            this.parentApp.speakAction('Failed to start P2P session');
        }
    }

    getAudioConstraints() {
        // High-quality audio constraints based on codec selection
        const baseConstraints = {
            audio: {
                echoCancellation: false, // Like SonoBus
                noiseSuppression: false,
                autoGainControl: false,
                channelCount: 2,
                sampleRate: 48000
            },
            video: false
        };

        // Adjust constraints based on selected codec
        switch (this.audioCodec) {
            case 'pcm-24':
                baseConstraints.audio.sampleSize = 24;
                break;
            case 'pcm-16':
                baseConstraints.audio.sampleSize = 16;
                break;
            default:
                // Opus settings handled in WebRTC configuration
                break;
        }

        return baseConstraints;
    }

    async createPeerConnection(peerId) {
        const pc = new RTCPeerConnection({ iceServers: this.iceServers });

        // Add local stream
        if (this.localStream) {
            this.localStream.getTracks().forEach(track => {
                pc.addTrack(track, this.localStream);
            });
        }

        // Handle incoming stream
        pc.ontrack = (event) => {
            this.handleRemoteStream(peerId, event.streams[0]);
        };

        // Handle ICE candidates
        pc.onicecandidate = (event) => {
            if (event.candidate) {
                this.sendIceCandidate(peerId, event.candidate);
            }
        };

        // Connection state monitoring
        pc.onconnectionstatechange = () => {
            this.handleConnectionStateChange(peerId, pc.connectionState);
        };

        this.connections.set(peerId, pc);
        return pc;
    }

    async handleRemoteStream(peerId, stream) {
        try {
            // Process remote audio through our audio context
            const audioElement = new Audio();
            audioElement.srcObject = stream;
            audioElement.volume = this.outputVolume;
            audioElement.muted = this.outputMuted;

            // Store audio element for volume control
            this.audioNodes.set(peerId, audioElement);

            // Auto-play if not muted
            if (!this.outputMuted) {
                await audioElement.play();
            }

            this.updateConnectionsList();
            console.log(`Remote stream from ${peerId} connected`);

        } catch (error) {
            console.error('Failed to handle remote stream:', error);
        }
    }

    startHostSession() {
        // In a real implementation, this would start a signaling server
        // For now, we'll simulate the hosting state
        this.updateConnectionStatus('Hosting session - waiting for connections', 'hosting');
        this.showConnectionControls(true);
    }

    async joinSession() {
        const remoteIP = document.getElementById('remoteIP').value;
        const sessionName = document.getElementById('joinSessionName').value;

        if (!remoteIP || !sessionName) {
            throw new Error('Remote IP and session name are required');
        }

        // In a real implementation, this would connect to the remote host
        // For now, we'll simulate the connection
        this.updateConnectionStatus(`Connecting to ${remoteIP}...`, 'connecting');

        // Simulate connection delay
        setTimeout(() => {
            this.isConnected = true;
            this.updateConnectionStatus(`Connected to ${sessionName}`, 'connected');
            this.showConnectionControls(true);
        }, 2000);
    }

    updateConnectionStatus(message, state) {
        const statusElement = document.getElementById('p2pStatus');
        const statusText = document.getElementById('statusText');
        const qualityInfo = document.getElementById('qualityInfo');

        if (statusElement && statusText) {
            statusElement.style.display = 'block';
            statusText.textContent = message;

            // Update quality info
            if (qualityInfo && this.isConnected) {
                const codec = this.audioCodec.toUpperCase();
                const latency = this.bufferSize <= 128 ? 'Ultra Low' :
                              this.bufferSize <= 256 ? 'Low' : 'Normal';
                qualityInfo.textContent = `Quality: ${codec} | Latency: ${latency} | Buffer: ${this.bufferSize} samples`;
            }

            // Update status styling
            statusElement.className = `p2p-status status-${state}`;
        }
    }

    showConnectionControls(show) {
        const controlsElement = document.getElementById('p2pAudioControls');
        const connectionsElement = document.getElementById('activeConnections');
        const startButton = document.getElementById('startP2P');
        const stopButton = document.getElementById('stopP2P');

        if (controlsElement) {
            controlsElement.style.display = show ? 'block' : 'none';
        }

        if (connectionsElement) {
            connectionsElement.style.display = show ? 'block' : 'none';
        }

        if (startButton) startButton.disabled = show;
        if (stopButton) stopButton.disabled = !show;
    }

    updateConnectionsList() {
        const listElement = document.getElementById('connectionsList');
        if (!listElement) return;

        listElement.innerHTML = '';

        for (const [peerId, connection] of this.connections) {
            const connectionDiv = document.createElement('div');
            connectionDiv.className = 'connection-item';
            connectionDiv.innerHTML = `
                <div class="connection-info">
                    <strong>${peerId}</strong>
                    <span class="connection-state">${connection.connectionState}</span>
                </div>
                <div class="connection-controls">
                    <button onclick="p2pManager.muteUser('${peerId}')">Mute</button>
                    <button onclick="p2pManager.disconnectUser('${peerId}')">Disconnect</button>
                </div>
            `;
            listElement.appendChild(connectionDiv);
        }
    }

    adjustVolume(type, value) {
        if (type === 'input') {
            this.inputVolume = Math.max(0, Math.min(1, value));
            if (this.gainInputNode) {
                this.gainInputNode.gain.value = this.inputVolume;
            }
        } else if (type === 'output') {
            this.outputVolume = Math.max(0, Math.min(1, value));

            // Update all remote audio elements
            for (const [peerId, audioElement] of this.audioNodes) {
                if (audioElement) {
                    audioElement.volume = this.outputVolume;
                }
            }
        }
    }

    toggleMute(type) {
        if (type === 'input') {
            this.inputMuted = !this.inputMuted;
            // Mute local stream tracks
            if (this.localStream) {
                this.localStream.getAudioTracks().forEach(track => {
                    track.enabled = !this.inputMuted;
                });
            }
            return this.inputMuted;
        } else if (type === 'output') {
            this.outputMuted = !this.outputMuted;
            // Mute all remote audio elements
            for (const [peerId, audioElement] of this.audioNodes) {
                if (audioElement) {
                    audioElement.muted = this.outputMuted;
                }
            }
            return this.outputMuted;
        }
    }

    disconnect() {
        // Close all peer connections
        for (const [peerId, connection] of this.connections) {
            connection.close();
        }
        this.connections.clear();

        // Stop local stream
        if (this.localStream) {
            this.localStream.getTracks().forEach(track => track.stop());
            this.localStream = null;
        }

        // Clean up audio nodes
        this.audioNodes.clear();

        this.isConnected = false;
        this.updateConnectionStatus('Disconnected', 'disconnected');
        this.showConnectionControls(false);
        this.parentApp.speakAction('P2P session disconnected');
    }

    // Event handlers for UI
    handleConnectionModeChange() {
        const mode = document.getElementById('p2pMode').value;
        const hostOptions = document.getElementById('hostOptions');
        const joinOptions = document.getElementById('joinOptions');

        if (hostOptions && joinOptions) {
            hostOptions.style.display = mode === 'host' ? 'block' : 'none';
            joinOptions.style.display = mode === 'join' ? 'block' : 'none';
        }
    }
}

// ===== ACCESSIBILITY SYSTEM =====
// Comprehensive accessibility and announcements system for FlexPhone

class AccessibilityManager {
    constructor() {
        this.screenReaderDetected = false;
        this.announcementSettings = this.loadAnnouncementSettings();
        this.politeRegion = null;
        this.assertiveRegion = null;
        this.notificationQueue = [];
        this.isProcessingQueue = false;

        // Speech synthesis properties
        this.speechSynthesis = window.speechSynthesis;
        this.voices = [];
        this.voiceSettings = this.loadVoiceSettings();
        this.speechQueue = [];
        this.isSpeaking = false;

        this.initializeAccessibilitySystem();
    }

    initializeAccessibilitySystem() {
        this.detectScreenReader();
        this.initializeLiveRegions();
        this.initializeSpeechSynthesis();

        console.log('ðŸ”Š FlexPhone Accessibility system initialized', {
            screenReader: this.screenReaderDetected,
            speechSynthesis: this.speechSynthesis !== null
        });

        // Announce FlexPhone startup
        setTimeout(() => {
            this.announceToScreenReader('FlexPhone accessibility system enabled. SIP phone interface ready.', 'polite');
        }, 1000);
    }

    detectScreenReader() {
        const srElements = document.querySelectorAll('.sr-only, [aria-live], [role="status"], [role="alert"]');
        const userAgent = navigator.userAgent.toLowerCase();
        const hasScreenReaderUA = userAgent.includes('nvda') || userAgent.includes('jaws') || userAgent.includes('voiceover');
        const hasHighContrast = window.matchMedia('(prefers-contrast: high)').matches;
        const hasReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
        const hasForcedColors = window.matchMedia('(forced-colors: active)').matches;

        this.screenReaderDetected = srElements.length > 0 || hasScreenReaderUA || hasHighContrast || hasReducedMotion || hasForcedColors;
    }

    initializeLiveRegions() {
        this.politeRegion = document.getElementById('live-region-polite');
        this.assertiveRegion = document.getElementById('live-region-assertive');
    }

    initializeSpeechSynthesis() {
        if (!this.speechSynthesis) return;

        this.loadVoices();
        this.speechSynthesis.addEventListener('voiceschanged', () => {
            this.loadVoices();
        });
    }

    loadVoices() {
        if (!this.speechSynthesis) return;
        this.voices = this.speechSynthesis.getVoices();

        if (!this.voiceSettings.selectedVoice && this.voices.length > 0) {
            const englishVoice = this.voices.find(voice =>
                voice.lang.startsWith('en') && !voice.name.includes('Google')
            );
            this.voiceSettings.selectedVoice = englishVoice ? englishVoice.name : this.voices[0].name;
        }
    }

    loadAnnouncementSettings() {
        const defaults = {
            callEvents: true,
            dialEvents: true,
            statusEvents: true,
            errorEvents: true,
            systemEvents: true
        };

        try {
            const saved = localStorage.getItem('flexphone-announcements');
            return saved ? { ...defaults, ...JSON.parse(saved) } : defaults;
        } catch (error) {
            return defaults;
        }
    }

    loadVoiceSettings() {
        const defaults = {
            mode: 'screen-reader',
            selectedVoice: '',
            rate: 1.0,
            pitch: 1.0,
            volume: 0.8
        };

        try {
            const saved = localStorage.getItem('flexphone-voice-settings');
            return saved ? { ...defaults, ...JSON.parse(saved) } : defaults;
        } catch (error) {
            return defaults;
        }
    }

    announceToScreenReader(message, priority = 'polite') {
        if (!message) return;

        // ARIA live regions
        if (this.screenReaderDetected && (this.voiceSettings.mode === 'screen-reader' || this.voiceSettings.mode === 'both')) {
            const region = priority === 'assertive' ? this.assertiveRegion : this.politeRegion;
            if (region) {
                this.notificationQueue.push({ message, priority, region });
                if (!this.isProcessingQueue) {
                    this.processAnnouncementQueue();
                }
            }
        }

        // System voice synthesis
        if (this.voiceSettings.mode === 'system-voice' || this.voiceSettings.mode === 'both') {
            this.speakWithSystemVoice(message, priority);
        }
    }

    async processAnnouncementQueue() {
        this.isProcessingQueue = true;

        while (this.notificationQueue.length > 0) {
            const { message, region } = this.notificationQueue.shift();
            region.textContent = '';
            await new Promise(resolve => setTimeout(resolve, 100));
            region.textContent = message;
            await new Promise(resolve => setTimeout(resolve, 1500));
            region.textContent = '';
            await new Promise(resolve => setTimeout(resolve, 300));
        }

        this.isProcessingQueue = false;
    }

    speakWithSystemVoice(text, priority = 'polite') {
        if (!this.speechSynthesis || this.voiceSettings.mode === 'screen-reader') return false;

        try {
            this.speechSynthesis.cancel();
            const utterance = new SpeechSynthesisUtterance(text);

            const selectedVoice = this.voices.find(voice => voice.name === this.voiceSettings.selectedVoice);
            if (selectedVoice) utterance.voice = selectedVoice;

            utterance.rate = this.voiceSettings.rate;
            utterance.pitch = this.voiceSettings.pitch;
            utterance.volume = this.voiceSettings.volume;

            if (priority === 'assertive') {
                utterance.rate = Math.min(this.voiceSettings.rate * 0.9, 1.0);
                utterance.pitch = Math.max(this.voiceSettings.pitch * 1.1, 2.0);
            }

            this.speechSynthesis.speak(utterance);
            return true;
        } catch (error) {
            console.error('Speech synthesis failed:', error);
            return false;
        }
    }

    // Specific announcement methods for FlexPhone events
    announceCall(event, details = '') {
        if (this.announcementSettings.callEvents) {
            this.announceToScreenReader(`Call ${event}. ${details}`, 'assertive');
        }
    }

    announceDial(event, details = '') {
        if (this.announcementSettings.dialEvents) {
            this.announceToScreenReader(`Dial ${event}. ${details}`, 'polite');
        }
    }

    announceStatus(event, details = '') {
        if (this.announcementSettings.statusEvents) {
            this.announceToScreenReader(`Status: ${event}. ${details}`, 'polite');
        }
    }

    announceError(event, details = '') {
        if (this.announcementSettings.errorEvents) {
            this.announceToScreenReader(`Error: ${event}. ${details}`, 'assertive');
        }
    }

    announceSystem(event, details = '') {
        if (this.announcementSettings.systemEvents) {
            this.announceToScreenReader(`System: ${event}. ${details}`, 'polite');
        }
    }
}

// Initialize app when DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
    window.flexPhoneApp = new FlexPhoneApp();
    window.accessibilityManager = new AccessibilityManager();
});